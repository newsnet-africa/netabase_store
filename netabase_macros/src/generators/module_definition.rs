use syn::{Ident, ItemEnum};

use crate::{
    generators::module_definition::def_gen::{generate_enums, generate_into_inner},
    visitors::definitions_visitor::DefinitionsVisitor,
};

impl<'a> DefinitionsVisitor<'a> {
    pub fn generate_definitions(
        &self,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        generate_enums(&self.modules, definition, definition_key)
    }

    pub fn generate_definition_trait_impls(
        &self,
        definition: &Ident,
        definition_key: &Ident,
    ) -> proc_macro2::TokenStream {
        let models = self
            .modules
            .iter()
            .flat_map(|m| def_gen::generate_model_variants(&m.models, m.path.clone()));
        let _into_inner = generate_into_inner(models.collect());

        // Generate RecordStore implementation
        #[cfg(feature = "libp2p")]
        let record_store_impl = crate::generators::record_store::generate_record_store_impl(
            &self.modules,
            definition,
            definition_key,
        );

        #[cfg(not(feature = "libp2p"))]
        let record_store_impl = quote::quote! {};

        // Generate apply_to_store implementation for Paxos consensus
        let apply_to_store_impl = def_gen::generate_apply_to_store_impl(&self.modules, definition);

        // panic!("{:?}", into_inner.to_string());
        quote::quote! {
            impl ::netabase_store::traits::definition::NetabaseDefinitionTrait for #definition {
                type Keys = #definition_key;
            }

            impl ::netabase_store::traits::definition::NetabaseDefinitionTraitKey for #definition_key {

            }

            impl ::netabase_store::traits::convert::ToIVec for #definition {}
            impl ::netabase_store::traits::convert::ToIVec for #definition_key {}

            // Paxakos LogEntry implementation for consensus (conditional on paxos feature)
            #[cfg(feature = "paxos")]
            impl ::netabase_deps::paxakos::LogEntry for #definition {
                /// Use the Keys enum as the ID
                /// This directly maps log entries to their database primary keys
                type Id = #definition_key;

                fn id(&self) -> Self::Id {
                    // Extract the primary key from the model
                    use ::netabase_store::traits::model::NetabaseModelTrait;
                    self.primary_key()
                }
            }

            // RecordStore implementation (generated by macro)
            #record_store_impl

            // Apply-to-store implementation for Paxos consensus
            // (only generated when paxos and libp2p features are enabled)
            #apply_to_store_impl
        }
    }
}

pub mod def_gen {
    use syn::{
        Arm, Ident, ItemEnum, ItemStruct, PathSegment, Token, Variant, parse_quote,
        punctuated::Punctuated,
    };

    use crate::item_info::netabase_definitions::ModuleInfo;

    pub fn generate_model_variants(
        structs: &[&ItemStruct],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        structs
            .iter()
            .map(|s| {
                let name = &s.ident;
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_into_inner(variants: Vec<Variant>) -> proc_macro2::TokenStream {
        let arms: Vec<Arm> = variants
            .iter()
            .map(|v| {
                let id = &v.ident;
                parse_quote! {
                    Self::#id(x) => x.clone()
                }
            })
            .collect();
        quote::quote! {
            fn into_inner(self) -> Box<dyn NetabaseModelTrait<Self>> {
                match self {
                    #(#arms),*
                }
            }
        }
    }

    pub fn generate_model_key_variants(
        keys: &[Ident],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        keys.iter()
            .map(|name| {
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_enums(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        let models = modules
            .iter()
            .flat_map(|m| generate_model_variants(&m.models, m.path.clone()));
        let keys = modules
            .iter()
            .flat_map(|m| generate_model_key_variants(&m.keys, m.path.clone()));

        let mut def_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, ::netabase_deps::strum::EnumDiscriminants,
                ::netabase_deps::derive_more::From,::netabase_deps::derive_more::TryInto,
                ::netabase_deps::bincode::Encode, ::netabase_deps::bincode::Decode,
                ::netabase_deps::serde::Serialize, ::netabase_deps::serde::Deserialize,
                ::netabase_deps::strum::Display
            )]
            #[strum_discriminants(derive(Hash, ::netabase_deps::strum::EnumIter, ::netabase_deps::strum::EnumString,
            ::netabase_deps::strum::Display, ::netabase_deps::strum::AsRefStr))]
            pub enum #definition {
                #(#models),*
            }
        };

        if cfg!(feature = "uniffi") {
            let uniffi_attr: syn::Attribute = parse_quote!(#[derive(uniffi::Enum)]);
            def_enum.attrs.push(uniffi_attr);
        }

        let mut def_key_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,
                ::netabase_deps::strum::EnumDiscriminants,
                ::netabase_deps::derive_more::From, ::netabase_deps::derive_more::TryInto,
                ::netabase_deps::bincode::Encode, ::netabase_deps::bincode::Decode
            )]
            #[strum_discriminants(derive(Hash, ::netabase_deps::strum::EnumString,
            ::netabase_deps::strum::AsRefStr,
            ::netabase_deps::strum::Display))]
            pub enum #definition_key {
                #(#keys),*
            }
        };

        if cfg!(feature = "uniffi") {
            let uniffi_attr: syn::Attribute = parse_quote!(#[derive(uniffi::Enum)]);
            def_key_enum.attrs.push(uniffi_attr);
        }

        (def_enum, def_key_enum)
    }

    /// Generate the apply_to_store implementation for Paxos consensus
    ///
    /// This method enables Paxos to apply committed entries to the store by
    /// routing each Definition variant to the appropriate store operation.
    pub fn generate_apply_to_store_impl(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
    ) -> proc_macro2::TokenStream {
        // Generate match arms for each model variant
        let match_arms: Vec<proc_macro2::TokenStream> = modules
            .iter()
            .flat_map(|module| {
                module.models.iter().map(|model_struct| {
                    let model_name = &model_struct.ident;

                    // Generate match arm that converts Definition variant to Record and stores it
                    quote::quote! {
                        Self::#model_name(model) => {
                            // Convert the model to a libp2p Record
                            use ::netabase_store::traits::model::NetabaseModelTrait;
                            use ::netabase_store::convert::ToIVec;

                            // Create the record key: <discriminant>:<primary_key>
                            let discriminant = ::netabase_deps::strum::IntoEnumIterator::iter::<
                                <Self as ::netabase_deps::strum::IntoDiscriminant>::Discriminant
                            >()
                            .find(|d| d.as_ref() == stringify!(#model_name))
                            .ok_or_else(|| format!("Invalid discriminant for {}", stringify!(#model_name)))?;

                            let primary_key = model.primary_key();
                            let discriminant_bytes = discriminant.as_ref().as_bytes();
                            let key_bytes = primary_key.to_ivec()
                                .map_err(|e| format!("Failed to serialize key: {}", e))?;

                            let mut record_key = Vec::with_capacity(discriminant_bytes.len() + 1 + key_bytes.len());
                            record_key.extend_from_slice(discriminant_bytes);
                            record_key.push(b':');
                            record_key.extend_from_slice(&key_bytes);

                            // Serialize the model
                            let value = ::netabase_deps::bincode::encode_to_vec(
                                model,
                                ::netabase_deps::bincode::config::standard()
                            ).map_err(|e| format!("Failed to serialize model: {}", e))?;

                            // Create the Record
                            #[cfg(feature = "libp2p")]
                            {
                                let record = ::netabase_deps::libp2p::kad::Record {
                                    key: ::netabase_deps::libp2p::kad::RecordKey::new(&record_key),
                                    value,
                                    publisher: None,
                                    expires: None,
                                };

                                // Put the record into the store
                                store.put(record)
                                    .map_err(|e| format!("Failed to put record: {:?}", e))?;
                            }

                            #[cfg(not(feature = "libp2p"))]
                            {
                                return Err(format!("apply_to_store requires libp2p feature"));
                            }
                        }
                    }
                })
            })
            .collect();

        quote::quote! {
            #[cfg(all(feature = "paxos", feature = "libp2p"))]
            impl #definition {
                /// Apply this definition entry to a store
                ///
                /// This method is used by Paxos consensus to apply committed entries
                /// to the local database. It routes each variant to the appropriate
                /// tree in the store by converting the model to a libp2p Record and
                /// storing it.
                ///
                /// # Parameters
                /// - `store`: Mutable reference to any type that implements RecordStore
                ///
                /// # Returns
                /// Result indicating success or error
                ///
                /// # Example
                /// ```ignore
                /// use libp2p::kad::store::RecordStore;
                ///
                /// let entry = MyDefinition::User(user);
                /// entry.apply_to_store(&mut store)?;
                /// ```
                ///
                /// # Notes
                /// This method is only available when both `paxos` and `libp2p` features
                /// are enabled, as it's specifically designed for consensus integration.
                pub fn apply_to_store<S>(
                    &self,
                    store: &mut S,
                ) -> Result<(), String>
                where
                    S: ::netabase_deps::libp2p::kad::store::RecordStore,
                {
                    match self {
                        #(#match_arms)*
                    }
                    Ok(())
                }
            }
        }
    }
}
