use syn::{Ident, ItemEnum};

use crate::{
    generators::module_definition::def_gen::{generate_enums, generate_into_inner},
    visitors::definitions_visitor::DefinitionsVisitor,
};

impl<'a> DefinitionsVisitor<'a> {
    pub fn generate_definitions(
        &self,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        generate_enums(&self.modules, definition, definition_key)
    }

    pub fn generate_definition_trait_impls(
        &self,
        definition: &Ident,
        definition_key: &Ident,
        tables_name: &Ident,
    ) -> proc_macro2::TokenStream {
        let models = self
            .modules
            .iter()
            .flat_map(|m| def_gen::generate_model_variants(&m.models, m.path.clone()));
        let _into_inner = generate_into_inner(models.collect());

        // Generate RecordStore implementation
        // Always generate - cfg attributes in the generated code will filter at user crate compile time
        let record_store_impl = crate::generators::record_store::generate_record_store_impl(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate apply_to_store implementation for Paxos consensus
        let apply_to_store_impl = def_gen::generate_apply_to_store_impl(&self.modules, definition);

        // Generate helper functions needed by RecordStoreExt trait methods
        let helper_functions = crate::generators::record_store::generate_helper_functions(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate inherent methods for RecordStore operations (libp2p feature)
        // These are public methods on the Definition type, not trait methods
        let record_store_methods = crate::generators::record_store::generate_trait_methods(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate AsRef and Borrow implementations for all model types
        let as_ref_borrow_impls = def_gen::generate_as_ref_borrow_impls(&self.modules, definition);

        // panic!("{:?}", into_inner.to_string());
        quote::quote! {
            // Helper functions for RecordStore operations
            #helper_functions

            // RecordStore implementation (generated by macro)
            // Must be before trait impl because trait methods call these functions
            #record_store_impl

            impl ::netabase_store::traits::definition::NetabaseDefinitionTrait for #definition {
                type Keys = #definition_key;
                #[cfg(feature = "redb")]
                type Tables = #tables_name;

                #[cfg(feature = "redb")]
                fn tables() -> Self::Tables {
                    #tables_name::new()
                }
            }

            // Implement RecordStoreExt trait for RecordStore helper methods
            #[cfg(feature = "libp2p")]
            impl ::netabase_store::traits::definition::RecordStoreExt for #definition {
                #record_store_methods
            }

            impl ::netabase_store::traits::definition::NetabaseDefinitionTraitKey for #definition_key {

            }

            impl ::netabase_store::traits::convert::ToIVec for #definition {}
            impl ::netabase_store::traits::convert::ToIVec for #definition_key {}

            // AsRef and Borrow implementations for all inner model types
            #as_ref_borrow_impls

            // Apply-to-store implementation for Paxos consensus
            // (only generated when paxos and libp2p features are enabled)
            #apply_to_store_impl
        }
    }
}

pub mod def_gen {
    use syn::{
        Arm, Ident, ItemEnum, ItemStruct, PathSegment, Token, Variant, parse_quote,
        punctuated::Punctuated,
    };

    use crate::item_info::netabase_definitions::ModuleInfo;

    pub fn generate_model_variants(
        structs: &[&ItemStruct],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        structs
            .iter()
            .map(|s| {
                let name = &s.ident;
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_into_inner(variants: Vec<Variant>) -> proc_macro2::TokenStream {
        let arms: Vec<Arm> = variants
            .iter()
            .map(|v| {
                let id = &v.ident;
                parse_quote! {
                    Self::#id(x) => x.clone()
                }
            })
            .collect();
        quote::quote! {
            fn into_inner(self) -> Box<dyn NetabaseModelTrait<Self>> {
                match self {
                    #(#arms),*
                }
            }
        }
    }

    pub fn generate_model_key_variants(
        keys: &[Ident],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        keys.iter()
            .map(|name| {
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_enums(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        let models = modules
            .iter()
            .flat_map(|m| generate_model_variants(&m.models, m.path.clone()));
        let keys = modules
            .iter()
            .flat_map(|m| generate_model_key_variants(&m.keys, m.path.clone()));

        // Create discriminant type name
        let discriminant_name =
            syn::Ident::new(&format!("{}Discriminant", definition), definition.span());

        let mut def_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, ::netabase_store::strum::EnumDiscriminants,
                ::netabase_store::derive_more::From,::netabase_store::derive_more::TryInto,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode,
                ::netabase_store::serde::Serialize, ::netabase_store::serde::Deserialize,
                ::netabase_store::strum::Display
            )]
            #[strum_discriminants(name(#discriminant_name))]
            #[strum_discriminants(derive(Hash,
                ::netabase_store::strum::EnumIter, ::netabase_store::strum::EnumString,
                ::netabase_store::strum::AsRefStr, ::netabase_store::strum::Display,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode))]
            pub enum #definition {
                #(#models),*
            }
        };

        if cfg!(feature = "uniffi") {
            let uniffi_attr: syn::Attribute = parse_quote!(#[derive(uniffi::Enum)]);
            def_enum.attrs.push(uniffi_attr);
        }

        // Create key discriminant type name
        let key_discriminant_name = syn::Ident::new(
            &format!("{}Discriminant", definition_key),
            definition_key.span(),
        );

        let mut def_key_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,
                ::netabase_store::strum::EnumDiscriminants,
                ::netabase_store::derive_more::From, ::netabase_store::derive_more::TryInto,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode
            )]
            #[strum_discriminants(name(#key_discriminant_name))]
            #[strum_discriminants(derive(Hash,
                ::netabase_store::strum::EnumIter,
                ::netabase_store::strum::EnumString,
                ::netabase_store::strum::AsRefStr, ::netabase_store::strum::Display,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode))]
            pub enum #definition_key {
                #(#keys),*
            }
        };

        if cfg!(feature = "uniffi") {
            let uniffi_attr: syn::Attribute = parse_quote!(#[derive(uniffi::Enum)]);
            def_key_enum.attrs.push(uniffi_attr);
        }

        (def_enum, def_key_enum)
    }

    /// Generate the apply_to_store implementation for Paxos consensus
    ///
    /// This method enables Paxos to apply committed entries to the store by
    /// routing each Definition variant to the appropriate store operation.
    pub fn generate_apply_to_store_impl(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
    ) -> proc_macro2::TokenStream {
        // Generate match arms for each model variant
        let match_arms: Vec<proc_macro2::TokenStream> = modules
            .iter()
            .flat_map(|module| {
                module.models.iter().map(|model_struct| {
                    let model_name = &model_struct.ident;

                    // Generate match arm that converts Definition variant to Record and stores it
                    quote::quote! {
                        Self::#model_name(model) => {
                            // Convert the model to a libp2p Record
                            use ::netabase_store::traits::model::NetabaseModelTrait;
                            use ::netabase_store::convert::ToIVec;

                            // Create the record key: <discriminant>:<primary_key>
                            let discriminant = ::netabase_store::strum::IntoEnumIterator::iter::<
                                <Self as ::netabase_store::strum::IntoDiscriminant>::Discriminant
                            >()
                            .find(|d| d.as_ref() == stringify!(#model_name))
                            .ok_or_else(|| format!("Invalid discriminant for {}", stringify!(#model_name)))?;

                            let primary_key = model.primary_key();
                            let discriminant_bytes = discriminant.as_ref().as_bytes();
                            let key_bytes = primary_key.to_ivec()
                                .map_err(|e| format!("Failed to serialize key: {}", e))?;

                            let mut record_key = Vec::with_capacity(discriminant_bytes.len() + 1 + key_bytes.len());
                            record_key.extend_from_slice(discriminant_bytes);
                            record_key.push(b':');
                            record_key.extend_from_slice(&key_bytes);

                            // Serialize the model
                            let value = ::netabase_store::bincode::encode_to_vec(
                                model,
                                ::netabase_store::bincode::config::standard()
                            ).map_err(|e| format!("Failed to serialize model: {}", e))?;

                            // Create the Record
                            #[cfg(feature = "libp2p")]
                            {
                                let record = ::netabase_store::libp2p::kad::Record {
                                    key: ::netabase_store::libp2p::kad::RecordKey::new(&record_key),
                                    value,
                                    publisher: None,
                                    expires: None,
                                };

                                // Put the record into the store
                                store.put(record)
                                    .map_err(|e| format!("Failed to put record: {:?}", e))?;
                            }

                            #[cfg(not(feature = "libp2p"))]
                            {
                                return Err(format!("apply_to_store requires libp2p feature"));
                            }
                        }
                    }
                })
            })
            .collect();

        quote::quote! {
            #[cfg(all(feature = "paxos", feature = "libp2p"))]
            impl #definition {
                /// Apply this definition entry to a store
                ///
                /// This method is used by Paxos consensus to apply committed entries
                /// to the local database. It routes each variant to the appropriate
                /// tree in the store by converting the model to a libp2p Record and
                /// storing it.
                ///
                /// # Parameters
                /// - `store`: Mutable reference to any type that implements RecordStore
                ///
                /// # Returns
                /// Result indicating success or error
                ///
                /// # Example
                /// ```ignore
                /// use libp2p::kad::store::RecordStore;
                ///
                /// let entry = MyDefinition::User(user);
                /// entry.apply_to_store(&mut store)?;
                /// ```
                ///
                /// # Notes
                /// This method is only available when both `paxos` and `libp2p` features
                /// are enabled, as it's specifically designed for consensus integration.
                pub fn apply_to_store<S>(
                    &self,
                    store: &mut S,
                ) -> Result<(), String>
                where
                    S: ::netabase_store::libp2p::kad::store::RecordStore,
                {
                    match self {
                        #(#match_arms)*
                    }
                    Ok(())
                }
            }
        }
    }

    /// Generate AsRef and Borrow trait implementations for all inner model types
    ///
    /// This allows users to access the inner model through the Definition enum wrapper
    /// without unwrapping, cloning, or consuming the enum.
    ///
    /// # Example
    /// ```ignore
    /// fn process_user<T: AsRef<User>>(user: T) {
    ///     let user_ref = user.as_ref();
    ///     // ... use user_ref
    /// }
    ///
    /// let def = MyDefinition::User(user);
    /// process_user(&def); // Works due to AsRef<User> impl
    /// ```
    ///
    /// # Note
    /// These implementations will panic if called on the wrong variant.
    /// Users should ensure they're calling as_ref/borrow on the correct variant,
    /// or use the safe TryInto approach instead.
    pub fn generate_as_ref_borrow_impls(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
    ) -> proc_macro2::TokenStream {
        let impls: Vec<proc_macro2::TokenStream> = modules
            .iter()
            .flat_map(|module| {
                module.models.iter().map(|model_struct| {
                    let model_name = &model_struct.ident;

                    // Build the full path to the model type
                    let mut model_path = module.path.clone();
                    model_path.push(model_name.clone().into());

                    // Generate AsRef implementation
                    let as_ref_impl = quote::quote! {
                        impl ::std::convert::AsRef<#model_path> for #definition {
                            fn as_ref(&self) -> &#model_path {
                                match self {
                                    Self::#model_name(model) => model,
                                    _ => panic!(
                                        "Attempted to access {} from wrong variant. Use TryInto for safe variant access.",
                                        stringify!(#model_name)
                                    ),
                                }
                            }
                        }
                    };

                    // Generate Borrow implementation
                    let borrow_impl = quote::quote! {
                        impl ::std::borrow::Borrow<#model_path> for #definition {
                            fn borrow(&self) -> &#model_path {
                                match self {
                                    Self::#model_name(model) => model,
                                    _ => panic!(
                                        "Attempted to borrow {} from wrong variant. Use TryInto for safe variant access.",
                                        stringify!(#model_name)
                                    ),
                                }
                            }
                        }
                    };

                    quote::quote! {
                        #as_ref_impl
                        #borrow_impl
                    }
                })
            })
            .collect();

        quote::quote! {
            #(#impls)*
        }
    }
}
