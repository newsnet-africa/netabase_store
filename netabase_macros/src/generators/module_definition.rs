use syn::{Ident, ItemEnum};

use crate::{
    generators::module_definition::def_gen::{generate_enums, generate_into_inner},
    visitors::definitions_visitor::DefinitionsVisitor,
};

impl<'a> DefinitionsVisitor<'a> {
    pub fn generate_definitions(
        &self,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        generate_enums(&self.modules, definition, definition_key)
    }

    pub fn generate_definition_trait_impls(
        &self,
        definition: &Ident,
        definition_key: &Ident,
        tables_name: &Ident,
    ) -> proc_macro2::TokenStream {
        let models = self
            .modules
            .iter()
            .flat_map(|m| def_gen::generate_model_variants(&m.models, m.path.clone()));
        let _into_inner = generate_into_inner(models.collect());

        // Generate RecordStore implementation
        // Always generate - cfg attributes in the generated code will filter at user crate compile time
        let record_store_impl = crate::generators::record_store::generate_record_store_impl(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate helper functions needed by RecordStoreExt trait methods
        let helper_functions = crate::generators::record_store::generate_helper_functions(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate inherent methods for RecordStore operations (libp2p feature)
        // These are public methods on the Definition type, not trait methods
        let record_store_methods = crate::generators::record_store::generate_trait_methods(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate AsRef and Borrow implementations for all model types
        let as_ref_borrow_impls = def_gen::generate_as_ref_borrow_impls(&self.modules, definition);

        // Generate Tables impl based on MACRO's features, not user's features!
        // This is checked at macro expansion time, so no cfg in generated code.
        #[cfg(feature = "redb")]
        let tables_impl = quote::quote! {
            type Tables = #tables_name;

            fn tables() -> Self::Tables {
                #tables_name::new()
            }
        };

        #[cfg(not(feature = "redb"))]
        let tables_impl = quote::quote! {};

        #[cfg(not(feature = "redb"))]
        let libp2p_impl = quote::quote! {};
        #[cfg(feature = "libp2p")]
        let libp2p_impl = quote::quote! {

            // RecordStoreExt trait - conditional on libp2p feature
            // This trait is only defined when libp2p is enabled, so cfg is necessary
            impl ::netabase_store::traits::definition::RecordStoreExt for #definition {
                #record_store_methods
            }
        };

        quote::quote! {
            // Helper functions for RecordStore operations
            #helper_functions

            // RecordStore implementation (generated by macro)
            // Must be before trait impl because trait methods call these functions
            #record_store_impl

            // NO cfg attributes in generated code!
            // The macro checks its OWN features at expansion time and generates
            // the appropriate code. Users don't need any features enabled!
            impl ::netabase_store::traits::definition::NetabaseDefinitionTrait for #definition {
                type Keys = #definition_key;
                type SubscriptionManager = ();

                // This is generated based on netabase_macros' features,
                // not the user's features. No feature bleeding!
                #tables_impl

                fn subscription_manager() -> Self::SubscriptionManager {
                    ()
                }
            }

            #libp2p_impl
            impl ::netabase_store::traits::definition::NetabaseDefinitionTraitKey for #definition_key {

            }

            impl ::netabase_store::traits::convert::ToIVec for #definition {}
            impl ::netabase_store::traits::convert::ToIVec for #definition_key {}

            // AsRef and Borrow implementations for all inner model types
            #as_ref_borrow_impls
        }
    }

    pub fn generate_definition_trait_impls_with_subscriptions(
        &self,
        definition: &Ident,
        definition_key: &Ident,
        tables_name: &Ident,
        subscription_manager_name: &Ident,
    ) -> proc_macro2::TokenStream {
        let models = self
            .modules
            .iter()
            .flat_map(|m| def_gen::generate_model_variants(&m.models, m.path.clone()));
        let _into_inner = generate_into_inner(models.collect());

        // Generate RecordStore implementation
        let record_store_impl = crate::generators::record_store::generate_record_store_impl(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate helper functions needed by RecordStoreExt trait methods
        let helper_functions = crate::generators::record_store::generate_helper_functions(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate inherent methods for RecordStore operations (libp2p feature)
        let record_store_methods = crate::generators::record_store::generate_trait_methods(
            &self.modules,
            definition,
            definition_key,
        );

        // Generate AsRef and Borrow implementations for all model types
        let as_ref_borrow_impls = def_gen::generate_as_ref_borrow_impls(&self.modules, definition);

        // Generate Tables impl based on MACRO's features, not user's features!
        #[cfg(feature = "redb")]
        let tables_impl = quote::quote! {
            type Tables = #tables_name;

            fn tables() -> Self::Tables {
                #tables_name::new()
            }
        };

        #[cfg(not(feature = "redb"))]
        let tables_impl = quote::quote! {};

        #[cfg(not(feature = "redb"))]
        let libp2p_impl = quote::quote! {};
        #[cfg(feature = "libp2p")]
        let libp2p_impl = quote::quote! {
            // RecordStoreExt trait - conditional on libp2p feature
            impl ::netabase_store::traits::definition::RecordStoreExt for #definition {
                #record_store_methods
            }
        };

        quote::quote! {
            // Helper functions for RecordStore operations
            #helper_functions

            // RecordStore implementation (generated by macro)
            #record_store_impl

            // Implementation with subscriptions support
            impl ::netabase_store::traits::definition::NetabaseDefinitionTrait for #definition {
                type Keys = #definition_key;
                type SubscriptionManager = #subscription_manager_name;

                #tables_impl

                fn subscription_manager() -> Self::SubscriptionManager {
                    #subscription_manager_name::new()
                }
            }

            #libp2p_impl
            impl ::netabase_store::traits::definition::NetabaseDefinitionTraitKey for #definition_key {

            }

            impl ::netabase_store::traits::convert::ToIVec for #definition {}
            impl ::netabase_store::traits::convert::ToIVec for #definition_key {}

            // AsRef and Borrow implementations for all inner model types
            #as_ref_borrow_impls
        }
    }
}

pub mod def_gen {
    use syn::{
        Arm, Ident, ItemEnum, ItemStruct, PathSegment, Token, Variant, parse_quote,
        punctuated::Punctuated,
    };

    use crate::item_info::netabase_definitions::ModuleInfo;

    pub fn generate_model_variants(
        structs: &[&ItemStruct],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        structs
            .iter()
            .map(|s| {
                let name = &s.ident;
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_into_inner(variants: Vec<Variant>) -> proc_macro2::TokenStream {
        let arms: Vec<Arm> = variants
            .iter()
            .map(|v| {
                let id = &v.ident;
                parse_quote! {
                    Self::#id(x) => x.clone()
                }
            })
            .collect();
        quote::quote! {
            fn into_inner(self) -> Box<dyn NetabaseModelTrait<Self>> {
                match self {
                    #(#arms),*
                }
            }
        }
    }

    pub fn generate_model_key_variants(
        keys: &[Ident],
        path: Punctuated<PathSegment, Token![::]>,
    ) -> Vec<Variant> {
        keys.iter()
            .map(|name| {
                let mut inner_path = path.clone();
                inner_path.push(name.clone().into());
                parse_quote! {
                    #name(#inner_path)
                }
            })
            .collect()
    }
    pub fn generate_enums(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
        definition_key: &Ident,
    ) -> (ItemEnum, ItemEnum) {
        let models = modules
            .iter()
            .flat_map(|m| generate_model_variants(&m.models, m.path.clone()));
        let keys = modules
            .iter()
            .flat_map(|m| generate_model_key_variants(&m.keys, m.path.clone()));

        // Create discriminant type name
        let discriminant_name =
            syn::Ident::new(&format!("{}Discriminant", definition), definition.span());

        let def_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, ::netabase_store::strum::EnumDiscriminants,
                ::netabase_store::derive_more::From,::netabase_store::derive_more::TryInto,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode,
                ::netabase_store::serde::Serialize, ::netabase_store::serde::Deserialize,
                ::netabase_store::strum::Display
            )]
            #[strum_discriminants(name(#discriminant_name))]
            #[strum_discriminants(derive(Hash,
                ::netabase_store::strum::EnumIter, ::netabase_store::strum::EnumString,
                ::netabase_store::strum::AsRefStr, ::netabase_store::strum::Display,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode))]
            pub enum #definition {
                #(#models),*
            }
        };

        // #[cfg(feature = "uniffi")]
        // {
        //     let uniffi_attr: syn::Attribute =
        //         parse_quote!(#[derive(::netabase_store::uniffi::Enum)]);
        //     def_enum.attrs.push(uniffi_attr);
        // }

        // Create key discriminant type name
        let key_discriminant_name = syn::Ident::new(
            &format!("{}Discriminant", definition_key),
            definition_key.span(),
        );

        let def_key_enum: ItemEnum = parse_quote! {
            #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash,
                ::netabase_store::strum::EnumDiscriminants,
                ::netabase_store::derive_more::From, ::netabase_store::derive_more::TryInto,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode
            )]
            #[strum_discriminants(name(#key_discriminant_name))]
            #[strum_discriminants(derive(Hash,
                ::netabase_store::strum::EnumIter,
                ::netabase_store::strum::EnumString,
                ::netabase_store::strum::AsRefStr, ::netabase_store::strum::Display,
                ::netabase_store::bincode::Encode, ::netabase_store::bincode::Decode))]
            pub enum #definition_key {
                #(#keys),*
            }
        };

        // #[cfg(feature = "uniffi")]
        // {
        //     let uniffi_attr: syn::Attribute =
        //         parse_quote!(#[derive(::netabase_store::uniffi::Enum)]);
        //     def_key_enum.attrs.push(uniffi_attr);
        // }

        (def_enum, def_key_enum)
    }

    /// Generate AsRef and Borrow trait implementations for all inner model types
    ///
    /// This allows users to access the inner model through the Definition enum wrapper
    /// without unwrapping, cloning, or consuming the enum.
    ///
    /// # Example
    /// ```no_run
    /// fn process_user<T: AsRef<User>>(user: T) {
    ///     let user_ref = user.as_ref();
    ///     // ... use user_ref
    /// }
    ///
    /// let def = MyDefinition::User(user);
    /// process_user(&def); // Works due to AsRef<User> impl
    /// ```
    ///
    /// # Note
    /// These implementations will panic if called on the wrong variant.
    /// Users should ensure they're calling as_ref/borrow on the correct variant,
    /// or use the safe TryInto approach instead.
    pub fn generate_as_ref_borrow_impls(
        modules: &Vec<ModuleInfo<'_>>,
        definition: &Ident,
    ) -> proc_macro2::TokenStream {
        let impls: Vec<proc_macro2::TokenStream> = modules
            .iter()
            .flat_map(|module| {
                module.models.iter().map(|model_struct| {
                    let model_name = &model_struct.ident;

                    // Build the full path to the model type
                    let mut model_path = module.path.clone();
                    model_path.push(model_name.clone().into());

                    // Generate AsRef implementation
                    let as_ref_impl = quote::quote! {
                        impl ::std::convert::AsRef<#model_path> for #definition {
                            fn as_ref(&self) -> &#model_path {
                                match self {
                                    Self::#model_name(model) => model,
                                    _ => panic!(
                                        "Attempted to access {} from wrong variant. Use TryInto for safe variant access.",
                                        stringify!(#model_name)
                                    ),
                                }
                            }
                        }
                    };

                    // Generate Borrow implementation
                    let borrow_impl = quote::quote! {
                        impl ::std::borrow::Borrow<#model_path> for #definition {
                            fn borrow(&self) -> &#model_path {
                                match self {
                                    Self::#model_name(model) => model,
                                    _ => panic!(
                                        "Attempted to borrow {} from wrong variant. Use TryInto for safe variant access.",
                                        stringify!(#model_name)
                                    ),
                                }
                            }
                        }
                    };

                    quote::quote! {
                        #as_ref_impl
                        #borrow_impl
                    }
                })
            })
            .collect();

        quote::quote! {
            #(#impls)*
        }
    }
}
