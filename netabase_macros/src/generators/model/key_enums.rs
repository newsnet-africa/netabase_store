use proc_macro2::TokenStream;
use quote::quote;
use syn::Ident;
use crate::visitors::model::field::{FieldInfo, FieldKeyType, ModelFieldVisitor};
use crate::utils::naming::*;

/// Generator for key enums (Secondary, Relational, Blob, Subscription, Unified)
pub struct KeyEnumGenerator<'a> {
    visitor: &'a ModelFieldVisitor,
}

impl<'a> KeyEnumGenerator<'a> {
    pub fn new(visitor: &'a ModelFieldVisitor) -> Self {
        Self { visitor }
    }

    /// Generate all key enums for the model
    /// Note: Subscriptions enum is NOT generated here - it's generated by the definition-level macro
    /// because it needs to reference the DefinitionSubscriptions type
    pub fn generate(&self) -> TokenStream {
        let mut output = TokenStream::new();

        output.extend(self.generate_secondary_keys_enum());
        output.extend(self.generate_relational_keys_enum());

        // Subscriptions enum is generated by definition-level macro
        
        output.extend(self.generate_blob_keys_enum());
        output.extend(self.generate_blob_item_enum());

        output.extend(self.generate_unified_keys_enum());

        output
    }

    fn generate_secondary_keys_enum(&self) -> TokenStream {
        let model_name = &self.visitor.model_name;
        let enum_name = secondary_keys_enum_name(model_name);
        let tree_name = tree_name_type(&enum_name);

        // If no secondary keys, generate an enum with a None variant
        if self.visitor.secondary_keys.is_empty() {
            return quote! {
                // TreeName discriminant enum
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    strum::AsRefStr
                )]
                pub enum #tree_name {
                    None
                }

                // Main enum
                #[derive(
                    Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    Hash
                )]
                pub enum #enum_name {
                    None
                }

                // Implement IntoDiscriminant manually
                impl strum::IntoDiscriminant for #enum_name {
                    type Discriminant = #tree_name;

                    fn discriminant(&self) -> Self::Discriminant {
                        #tree_name::None
                    }
                }
            };
        }

        let variants: Vec<_> = self.visitor.secondary_keys
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                let variant_ident = Ident::new(&variant_name, field.name.span());
                let wrapper_type = field_wrapper_name(model_name, &field.name);

                quote! { #variant_ident(#wrapper_type) }
            })
            .collect();

        let tree_name_variants: Vec<_> = self.visitor.secondary_keys
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                Ident::new(&variant_name, field.name.span())
            })
            .collect();

        quote! {
            // TreeName discriminant enum
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                strum::AsRefStr
            )]
            pub enum #tree_name {
                #(#tree_name_variants),*
            }

            // Main enum
            #[derive(
                Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                Hash
            )]
            pub enum #enum_name {
                #(#variants),*
            }

            // Implement IntoDiscriminant manually
            impl strum::IntoDiscriminant for #enum_name {
                type Discriminant = #tree_name;

                fn discriminant(&self) -> Self::Discriminant {
                    match self {
                        #(#enum_name::#tree_name_variants(_) => #tree_name::#tree_name_variants),*
                    }
                }
            }
        }
    }

    fn generate_relational_keys_enum(&self) -> TokenStream {
        let model_name = &self.visitor.model_name;
        let enum_name = relational_keys_enum_name(model_name);
        let tree_name = tree_name_type(&enum_name);

        // If no relational keys, generate an enum with a None variant
        if self.visitor.relational_keys.is_empty() {
            return quote! {
                // TreeName discriminant enum
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    strum::AsRefStr
                )]
                pub enum #tree_name {
                    None
                }

                // Main enum
                #[derive(
                    Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    Hash
                )]
                pub enum #enum_name {
                    None
                }

                // Implement IntoDiscriminant manually
                impl strum::IntoDiscriminant for #enum_name {
                    type Discriminant = #tree_name;

                    fn discriminant(&self) -> Self::Discriminant {
                        #tree_name::None
                    }
                }
            };
        }

        let variants: Vec<_> = self.visitor.relational_keys
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                let variant_ident = Ident::new(&variant_name, field.name.span());
                let wrapper_type = field_wrapper_name(model_name, &field.name);

                quote! { #variant_ident(#wrapper_type) }
            })
            .collect();

        let tree_name_variants: Vec<_> = self.visitor.relational_keys
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                Ident::new(&variant_name, field.name.span())
            })
            .collect();

        quote! {
            // TreeName discriminant enum
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                strum::AsRefStr
            )]
            pub enum #tree_name {
                #(#tree_name_variants),*
            }

            // Main enum
            #[derive(
                Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                Hash
            )]
            pub enum #enum_name {
                #(#variants),*
            }

            // Implement IntoDiscriminant manually
            impl strum::IntoDiscriminant for #enum_name {
                type Discriminant = #tree_name;

                fn discriminant(&self) -> Self::Discriminant {
                    match self {
                        #(#enum_name::#tree_name_variants(_) => #tree_name::#tree_name_variants),*
                    }
                }
            }
        }
    }

    fn generate_subscriptions_enum(&self) -> TokenStream {
        // ... (unchanged, still unused here)
        TokenStream::new()
    }

    fn generate_blob_keys_enum(&self) -> TokenStream {
        let model_name = &self.visitor.model_name;
        let enum_name = blob_keys_enum_name(model_name);
        let tree_name = tree_name_type(&enum_name);
        let id_type = primary_key_type_name(model_name);

        // If no blob fields, generate an enum with a None variant
        if self.visitor.blob_fields.is_empty() {
            return quote! {
                // TreeName discriminant enum
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    strum::AsRefStr
                )]
                pub enum #tree_name {
                    None
                }

                // Main enum
                #[derive(
                    Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize,
                    Hash
                )]
                pub enum #enum_name {
                    None
                }

                // Implement IntoDiscriminant manually
                impl strum::IntoDiscriminant for #enum_name {
                    type Discriminant = #tree_name;

                    fn discriminant(&self) -> Self::Discriminant {
                        #tree_name::None
                    }
                }
            };
        }

        let variants: Vec<_> = self.visitor.blob_fields
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                let variant_ident = Ident::new(&variant_name, field.name.span());

                quote! { #variant_ident { owner: #id_type } }
            })
            .collect();

        let tree_name_variants: Vec<_> = self.visitor.blob_fields
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                Ident::new(&variant_name, field.name.span())
            })
            .collect();

        quote! {
            // TreeName discriminant enum
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                strum::AsRefStr
            )]
            pub enum #tree_name {
                #(#tree_name_variants),*
            }

            // Main enum
            #[derive(
                Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                Hash
            )]
            pub enum #enum_name {
                #(#variants),*
            }

            // Implement IntoDiscriminant manually
            impl strum::IntoDiscriminant for #enum_name {
                type Discriminant = #tree_name;

                fn discriminant(&self) -> Self::Discriminant {
                    match self {
                        #(#enum_name::#tree_name_variants { .. } => #tree_name::#tree_name_variants),*
                    }
                }
            }
        }
    }

    fn generate_blob_item_enum(&self) -> TokenStream {
        let model_name = &self.visitor.model_name;
        let enum_name = blob_item_enum_name(model_name);

        // If no blob fields, generate an empty struct (not an enum)
        if self.visitor.blob_fields.is_empty() {
            return quote! {
                #[derive(
                    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                    bincode::Encode, bincode::Decode,
                    serde::Serialize, serde::Deserialize
                )]
                pub struct #enum_name;
            };
        }

        let variants: Vec<_> = self.visitor.blob_fields
            .iter()
            .map(|field| {
                let variant_name = to_pascal_case(&field.name.to_string());
                let variant_ident = Ident::new(&variant_name, field.name.span());

                quote! { #variant_ident { index: u8, value: Vec<u8> } }
            })
            .collect();

        quote! {
            #[derive(
                Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize
            )]
            pub enum #enum_name {
                #(#variants),*
            }
        }
    }

    fn generate_unified_keys_enum(&self) -> TokenStream {
        let model_name = &self.visitor.model_name;
        let enum_name = unified_keys_enum_name(model_name);
        let id_type = primary_key_type_name(model_name);

        let mut variants = vec![quote! { Primary(#id_type) }];

        // Secondary
        let secondary_enum = secondary_keys_enum_name(model_name);
        variants.push(quote! { Secondary(#secondary_enum) });

        // Relational
        let relational_enum = relational_keys_enum_name(model_name);
        variants.push(quote! { Relational(#relational_enum) });

        // Subscription
        let subscription_enum = subscriptions_enum_name(model_name);
        variants.push(quote! { Subscription(#subscription_enum) });

        // Blob
        let blob_enum = blob_keys_enum_name(model_name);
        variants.push(quote! { Blob(#blob_enum) });

        quote! {
            #[derive(
                Clone, Eq, PartialEq, PartialOrd, Ord, Debug,
                bincode::Encode, bincode::Decode,
                serde::Serialize, serde::Deserialize,
                Hash
            )]
            pub enum #enum_name {
                #(#variants),*
            }
        }
    }
}

/// Helper function to convert snake_case to PascalCase
fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}
