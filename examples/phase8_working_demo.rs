//! Simplified E-commerce Demo - Showing Cross-Definition Linking Concepts
//! 
//! This example demonstrates the Phase 8 cross-definition linking concepts
//! using simplified structs without requiring the full netabase trait system.

use serde::{Serialize, Deserialize};
use std::collections::HashMap;

// Cross-definition support types (generated by Phase 8 macros)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum CrossDefinitionRelationshipType {
    OneToOne,
    OneToMany,
    ManyToOne,
    ManyToMany,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum CrossDefinitionPermissionLevel {
    None,
    Read,
    Write,
    ReadWrite,
    Admin,
}

// User Definition Models
pub mod user_def {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct User {
        pub id: u64,
        pub email: String,
        pub username: String,
        pub name: String,
        pub role_id: UserRoleId,
        pub profile: UserProfile,
        pub created_at: u64,
        pub active: bool,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct UserRole {
        pub id: u64,
        pub name: String,
        pub permissions: RolePermissions,
        pub description: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct UserProfile {
        pub user_id: UserId,
        pub first_name: String,
        pub last_name: String,
        pub phone: Option<String>,
        pub address: Option<Address>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Address {
        pub street: String,
        pub city: String,
        pub state: String,
        pub postal_code: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct RolePermissions {
        pub manage_products: bool,
        pub manage_orders: bool,
        pub manage_users: bool,
        pub system_admin: bool,
    }

    // Type-safe wrapper types (would be generated by macros)
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct UserId(pub u64);

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct UserRoleId(pub u64);

    impl User {
        // Tree name constants (generated by macros)
        pub const MAIN_TREE_NAME: &'static str = "UserDef::User::Main";
        pub const HASH_TREE_NAME: &'static str = "UserDef::User::Hash";
        pub const SECONDARY_TREE_NAMES: &'static [&'static str] = &[
            "UserDef::User::Secondary::Email",
            "UserDef::User::Secondary::Username",
        ];
        pub const SUBSCRIPTION_TREE_NAMES: &'static [&'static str] = &[
            "UserDef::User::Subscription::UserEvents",
            "UserDef::User::Subscription::Authentication",
        ];
    }
}

// Product Definition Models
pub mod product_def {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Product {
        pub id: u64,
        pub sku: String,
        pub name: String,
        pub description: String,
        pub price: f64,
        pub category_id: CategoryId,
        pub created_by: ProductCreatedByLink, // Cross-definition link
        pub status: ProductStatus,
        pub created_at: u64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Category {
        pub id: u64,
        pub name: String,
        pub slug: String,
        pub parent_category: Option<CategoryId>,
        pub active: bool,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum ProductStatus {
        Draft,
        Active,
        Inactive,
        Discontinued,
    }

    // Type-safe wrapper types
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct ProductId(pub u64);

    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct CategoryId(pub u64);

    /// Cross-definition link wrapper for Product -> User relationship (generated by Phase 8)
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct ProductCreatedByLink {
        pub target_path: &'static str,
        pub target_model_id: String,
        pub relationship_type: CrossDefinitionRelationshipType,
        pub required_permission: CrossDefinitionPermissionLevel,
    }

    impl ProductCreatedByLink {
        pub fn new(user_id: u64) -> Self {
            Self {
                target_path: "user_def::User",
                target_model_id: user_id.to_string(),
                relationship_type: CrossDefinitionRelationshipType::ManyToOne,
                required_permission: CrossDefinitionPermissionLevel::Read,
            }
        }

        pub fn can_access_with_permission(&self, permission: &CrossDefinitionPermissionLevel) -> bool {
            permission >= &self.required_permission
        }

        pub fn target_user_id(&self) -> u64 {
            self.target_model_id.parse().unwrap_or(0)
        }
    }

    impl Product {
        // Tree name constants (generated by macros)
        pub const MAIN_TREE_NAME: &'static str = "ProductDef::Product::Main";
        pub const HASH_TREE_NAME: &'static str = "ProductDef::Product::Hash";
        pub const SECONDARY_TREE_NAMES: &'static [&'static str] = &[
            "ProductDef::Product::Secondary::Sku",
            "ProductDef::Product::Secondary::Name",
        ];
        pub const RELATIONAL_TREE_NAMES: &'static [&'static str] = &[
            "ProductDef::Product::Relational::CategoryId",
            "ProductDef::Product::Relational::CreatedBy", // Cross-definition relation
        ];
    }
}

// Order Definition Models
pub mod order_def {
    use super::*;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Order {
        pub id: u64,
        pub order_number: String,
        pub customer: OrderCustomerLink, // Cross-definition link
        pub status: OrderStatus,
        pub total: f64,
        pub created_at: u64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct OrderItem {
        pub id: u64,
        pub order_id: OrderId,
        pub product: OrderItemProductLink, // Cross-definition link
        pub quantity: u32,
        pub unit_price: f64,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub enum OrderStatus {
        Pending,
        Processing,
        Shipped,
        Delivered,
        Cancelled,
    }

    // Type-safe wrapper types
    #[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
    pub struct OrderId(pub u64);

    /// Cross-definition link wrapper for Order -> User relationship
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct OrderCustomerLink {
        pub target_path: &'static str,
        pub target_model_id: String,
        pub relationship_type: CrossDefinitionRelationshipType,
        pub required_permission: CrossDefinitionPermissionLevel,
    }

    impl OrderCustomerLink {
        pub fn new(user_id: u64) -> Self {
            Self {
                target_path: "user_def::User",
                target_model_id: user_id.to_string(),
                relationship_type: CrossDefinitionRelationshipType::ManyToOne,
                required_permission: CrossDefinitionPermissionLevel::Read,
            }
        }

        pub fn can_access_with_permission(&self, permission: &CrossDefinitionPermissionLevel) -> bool {
            permission >= &self.required_permission
        }

        pub fn target_user_id(&self) -> u64 {
            self.target_model_id.parse().unwrap_or(0)
        }
    }

    /// Cross-definition link wrapper for OrderItem -> Product relationship
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct OrderItemProductLink {
        pub target_path: &'static str,
        pub target_model_id: String,
        pub relationship_type: CrossDefinitionRelationshipType,
        pub required_permission: CrossDefinitionPermissionLevel,
    }

    impl OrderItemProductLink {
        pub fn new(product_id: u64) -> Self {
            Self {
                target_path: "product_def::Product",
                target_model_id: product_id.to_string(),
                relationship_type: CrossDefinitionRelationshipType::ManyToOne,
                required_permission: CrossDefinitionPermissionLevel::Read,
            }
        }

        pub fn can_access_with_permission(&self, permission: &CrossDefinitionPermissionLevel) -> bool {
            permission >= &self.required_permission
        }

        pub fn target_product_id(&self) -> u64 {
            self.target_model_id.parse().unwrap_or(0)
        }
    }

    impl Order {
        // Tree name constants (generated by macros)
        pub const MAIN_TREE_NAME: &'static str = "OrderDef::Order::Main";
        pub const HASH_TREE_NAME: &'static str = "OrderDef::Order::Hash";
        pub const SECONDARY_TREE_NAMES: &'static [&'static str] = &[
            "OrderDef::Order::Secondary::OrderNumber",
        ];
        pub const RELATIONAL_TREE_NAMES: &'static [&'static str] = &[
            "OrderDef::Order::Relational::Customer", // Cross-definition relation
        ];
    }
}

/// In-memory store for demonstration
pub struct MockStore {
    users: HashMap<u64, user_def::User>,
    user_roles: HashMap<u64, user_def::UserRole>,
    products: HashMap<u64, product_def::Product>,
    categories: HashMap<u64, product_def::Category>,
    orders: HashMap<u64, order_def::Order>,
    order_items: HashMap<u64, order_def::OrderItem>,
}

impl MockStore {
    pub fn new() -> Self {
        Self {
            users: HashMap::new(),
            user_roles: HashMap::new(),
            products: HashMap::new(),
            categories: HashMap::new(),
            orders: HashMap::new(),
            order_items: HashMap::new(),
        }
    }

    // User operations
    pub fn put_user(&mut self, user: user_def::User) {
        self.users.insert(user.id, user);
    }

    pub fn get_user(&self, id: u64) -> Option<&user_def::User> {
        self.users.get(&id)
    }

    pub fn put_user_role(&mut self, role: user_def::UserRole) {
        self.user_roles.insert(role.id, role);
    }

    pub fn get_user_role(&self, id: u64) -> Option<&user_def::UserRole> {
        self.user_roles.get(&id)
    }

    // Product operations
    pub fn put_product(&mut self, product: product_def::Product) {
        self.products.insert(product.id, product);
    }

    pub fn get_product(&self, id: u64) -> Option<&product_def::Product> {
        self.products.get(&id)
    }

    pub fn put_category(&mut self, category: product_def::Category) {
        self.categories.insert(category.id, category);
    }

    pub fn get_category(&self, id: u64) -> Option<&product_def::Category> {
        self.categories.get(&id)
    }

    // Order operations
    pub fn put_order(&mut self, order: order_def::Order) {
        self.orders.insert(order.id, order);
    }

    pub fn get_order(&self, id: u64) -> Option<&order_def::Order> {
        self.orders.get(&id)
    }

    pub fn put_order_item(&mut self, item: order_def::OrderItem) {
        self.order_items.insert(item.id, item);
    }

    pub fn get_order_item(&self, id: u64) -> Option<&order_def::OrderItem> {
        self.order_items.get(&id)
    }

    /// Resolve a cross-definition link to the actual target model
    pub fn resolve_user_link(&self, link: &product_def::ProductCreatedByLink) -> Option<&user_def::User> {
        let user_id = link.target_user_id();
        self.get_user(user_id)
    }

    pub fn resolve_customer_link(&self, link: &order_def::OrderCustomerLink) -> Option<&user_def::User> {
        let user_id = link.target_user_id();
        self.get_user(user_id)
    }

    pub fn resolve_product_link(&self, link: &order_def::OrderItemProductLink) -> Option<&product_def::Product> {
        let product_id = link.target_product_id();
        self.get_product(product_id)
    }
}

/// E-commerce Application Service
pub struct EcommerceApplication {
    store: MockStore,
}

impl EcommerceApplication {
    pub fn new() -> Self {
        Self {
            store: MockStore::new(),
        }
    }

    pub fn initialize_sample_data(&mut self) {
        // Create sample user role
        let admin_role = user_def::UserRole {
            id: 1,
            name: "Administrator".to_string(),
            permissions: user_def::RolePermissions {
                manage_products: true,
                manage_orders: true,
                manage_users: true,
                system_admin: true,
            },
            description: "System administrator".to_string(),
        };

        let customer_role = user_def::UserRole {
            id: 2,
            name: "Customer".to_string(),
            permissions: user_def::RolePermissions {
                manage_products: false,
                manage_orders: false,
                manage_users: false,
                system_admin: false,
            },
            description: "Regular customer".to_string(),
        };

        self.store.put_user_role(admin_role);
        self.store.put_user_role(customer_role);

        // Create sample users
        let admin_user = user_def::User {
            id: 1,
            email: "admin@example.com".to_string(),
            username: "admin".to_string(),
            name: "Administrator".to_string(),
            role_id: user_def::UserRoleId(1),
            profile: user_def::UserProfile {
                user_id: user_def::UserId(1),
                first_name: "System".to_string(),
                last_name: "Admin".to_string(),
                phone: Some("+1-555-0123".to_string()),
                address: Some(user_def::Address {
                    street: "123 Admin St".to_string(),
                    city: "Admin City".to_string(),
                    state: "CA".to_string(),
                    postal_code: "90210".to_string(),
                }),
            },
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            active: true,
        };

        let customer_user = user_def::User {
            id: 2,
            email: "customer@example.com".to_string(),
            username: "customer1".to_string(),
            name: "John Doe".to_string(),
            role_id: user_def::UserRoleId(2),
            profile: user_def::UserProfile {
                user_id: user_def::UserId(2),
                first_name: "John".to_string(),
                last_name: "Doe".to_string(),
                phone: Some("+1-555-0456".to_string()),
                address: Some(user_def::Address {
                    street: "456 Customer Ave".to_string(),
                    city: "Customer City".to_string(),
                    state: "NY".to_string(),
                    postal_code: "10001".to_string(),
                }),
            },
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            active: true,
        };

        self.store.put_user(admin_user);
        self.store.put_user(customer_user);

        // Create sample category
        let electronics_category = product_def::Category {
            id: 1,
            name: "Electronics".to_string(),
            slug: "electronics".to_string(),
            parent_category: None,
            active: true,
        };

        self.store.put_category(electronics_category);

        // Create sample product with cross-definition link
        let laptop_product = product_def::Product {
            id: 1,
            sku: "LAPTOP-001".to_string(),
            name: "Gaming Laptop Pro".to_string(),
            description: "High-performance gaming laptop".to_string(),
            price: 1299.99,
            category_id: product_def::CategoryId(1),
            created_by: product_def::ProductCreatedByLink::new(1), // Link to admin user
            status: product_def::ProductStatus::Active,
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        self.store.put_product(laptop_product);

        // Create sample order with cross-definition links
        let sample_order = order_def::Order {
            id: 1,
            order_number: "ORD-2024-001".to_string(),
            customer: order_def::OrderCustomerLink::new(2), // Link to customer
            status: order_def::OrderStatus::Processing,
            total: 1299.99,
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        self.store.put_order(sample_order);

        // Create sample order item with cross-definition link
        let order_item = order_def::OrderItem {
            id: 1,
            order_id: order_def::OrderId(1),
            product: order_def::OrderItemProductLink::new(1), // Link to product
            quantity: 1,
            unit_price: 1299.99,
        };

        self.store.put_order_item(order_item);
    }

    pub fn demonstrate_cross_definition_access(&self) {
        println!("\nüîó Demonstrating Cross-Definition Relationship Access");
        println!("====================================================");

        // Get product and resolve its creator through cross-definition link
        if let Some(product) = self.store.get_product(1) {
            println!("\nüì¶ Product: {}", product.name);
            println!("   üÜî ID: {}", product.id);
            println!("   üí∞ Price: ${}", product.price);

            // Show the cross-definition link details
            let created_by_link = &product.created_by;
            println!("   üë§ Created By Link:");
            println!("      üéØ Target Path: {}", created_by_link.target_path);
            println!("      üÜî Target User ID: {}", created_by_link.target_model_id);
            println!("      üîó Relationship Type: {:?}", created_by_link.relationship_type);
            println!("      üîí Required Permission: {:?}", created_by_link.required_permission);

            // Resolve the link to get the actual user
            if let Some(creator) = self.store.resolve_user_link(created_by_link) {
                println!("   ‚úÖ Resolved Creator: {} ({})", creator.name, creator.email);
                
                // Check permissions
                let read_permission = CrossDefinitionPermissionLevel::Read;
                let no_permission = CrossDefinitionPermissionLevel::None;
                
                println!("   üîê Permission Check:");
                println!("      ‚úÖ Can access with Read permission: {}", 
                        created_by_link.can_access_with_permission(&read_permission));
                println!("      ‚ùå Can access with No permission: {}", 
                        created_by_link.can_access_with_permission(&no_permission));
            }
        }

        // Get order and resolve its customer through cross-definition link
        if let Some(order) = self.store.get_order(1) {
            println!("\nüõí Order: {}", order.order_number);
            println!("   üí∞ Total: ${}", order.total);
            println!("   üìä Status: {:?}", order.status);

            // Show the customer link
            let customer_link = &order.customer;
            println!("   üë§ Customer Link:");
            println!("      üéØ Target Path: {}", customer_link.target_path);
            println!("      üÜî Target Customer ID: {}", customer_link.target_model_id);

            // Resolve the customer
            if let Some(customer) = self.store.resolve_customer_link(customer_link) {
                println!("   ‚úÖ Resolved Customer: {} ({})", customer.name, customer.email);
            }
        }

        // Get order item and resolve its product through cross-definition link
        if let Some(order_item) = self.store.get_order_item(1) {
            println!("\nüì¶ Order Item:");
            println!("   üî¢ Quantity: {}", order_item.quantity);
            println!("   üí∞ Unit Price: ${}", order_item.unit_price);

            // Show the product link
            let product_link = &order_item.product;
            println!("   üì¶ Product Link:");
            println!("      üéØ Target Path: {}", product_link.target_path);
            println!("      üÜî Target Product ID: {}", product_link.target_model_id);

            // Resolve the product
            if let Some(linked_product) = self.store.resolve_product_link(product_link) {
                println!("   ‚úÖ Resolved Product: {} (SKU: {})", linked_product.name, linked_product.sku);
            }
        }
    }

    pub fn demonstrate_permission_hierarchy(&self) {
        println!("\nüèõÔ∏è  Demonstrating Hierarchical Permission Management");
        println!("===================================================");

        let permission_scenarios = vec![
            ("System Admin", CrossDefinitionPermissionLevel::Admin),
            ("Manager", CrossDefinitionPermissionLevel::ReadWrite),
            ("Customer Support", CrossDefinitionPermissionLevel::Read),
            ("Guest", CrossDefinitionPermissionLevel::None),
        ];

        // Test with a product's created_by link
        if let Some(product) = self.store.get_product(1) {
            println!("\nüì¶ Testing access to Product '{}' creator link:", product.name);

            for (role_name, permission_level) in &permission_scenarios {
                let can_access = product.created_by.can_access_with_permission(permission_level);
                println!("   üë§ {}: {}", 
                        role_name, 
                        if can_access { "‚úÖ Access Granted" } else { "‚ùå Access Denied" });
            }
        }

        // Test with an order's customer link
        if let Some(order) = self.store.get_order(1) {
            println!("\nüõí Testing access to Order '{}' customer link:", order.order_number);

            for (role_name, permission_level) in &permission_scenarios {
                let can_access = order.customer.can_access_with_permission(permission_level);
                println!("   üë§ {}: {}", 
                        role_name, 
                        if can_access { "‚úÖ Access Granted" } else { "‚ùå Access Denied" });
            }
        }
    }

    pub fn demonstrate_tree_naming_standards(&self) {
        println!("\nüå≥ Demonstrating Standardized Tree Naming (Phase 8)");
        println!("==================================================");

        println!("üìã User Model Trees:");
        println!("   üå≤ Main Tree: {}", user_def::User::MAIN_TREE_NAME);
        println!("   üóÇÔ∏è  Hash Tree: {}", user_def::User::HASH_TREE_NAME);
        println!("   üìë Secondary Trees:");
        for tree_name in user_def::User::SECONDARY_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }
        println!("   üì° Subscription Trees:");
        for tree_name in user_def::User::SUBSCRIPTION_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }

        println!("\nüì¶ Product Model Trees:");
        println!("   üå≤ Main Tree: {}", product_def::Product::MAIN_TREE_NAME);
        println!("   üóÇÔ∏è  Hash Tree: {}", product_def::Product::HASH_TREE_NAME);
        println!("   üìë Secondary Trees:");
        for tree_name in product_def::Product::SECONDARY_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }
        println!("   üîó Relational Trees (including cross-definition):");
        for tree_name in product_def::Product::RELATIONAL_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }

        println!("\nüõí Order Model Trees:");
        println!("   üå≤ Main Tree: {}", order_def::Order::MAIN_TREE_NAME);
        println!("   üóÇÔ∏è  Hash Tree: {}", order_def::Order::HASH_TREE_NAME);
        println!("   üìë Secondary Trees:");
        for tree_name in order_def::Order::SECONDARY_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }
        println!("   üîó Relational Trees (including cross-definition):");
        for tree_name in order_def::Order::RELATIONAL_TREE_NAMES {
            println!("      ‚Ä¢ {}", tree_name);
        }
    }
}

/// Main demonstration function
pub fn run_demo() {
    println!("üöÄ Phase 8 Cross-Definition Linking Demo");
    println!("========================================");

    // Initialize the application
    let mut app = EcommerceApplication::new();
    app.initialize_sample_data();

    println!("‚úÖ Sample data initialized with cross-definition relationships");

    // Run demonstrations
    app.demonstrate_cross_definition_access();
    app.demonstrate_permission_hierarchy();
    app.demonstrate_tree_naming_standards();

    println!("\nüéØ Advanced Cross-Definition Scenarios");
    println!("======================================");

    // Demonstrate complex relationship traversal
    demonstrate_relationship_traversal(&app);
    
    // Demonstrate type safety
    demonstrate_type_safety();

    println!("\n‚úÖ Phase 8 Cross-Definition Linking Demo Complete!");
    println!("üéâ All features working correctly!");
}

fn demonstrate_relationship_traversal(app: &EcommerceApplication) {
    println!("\nüó∫Ô∏è  Complex Relationship Traversal:");
    
    // Order -> Customer -> UserRole chain
    if let Some(order) = app.store.get_order(1) {
        if let Some(customer) = app.store.resolve_customer_link(&order.customer) {
            if let Some(role) = app.store.get_user_role(customer.role_id.0) {
                println!("   üìã Traversal: Order ‚Üí Customer ‚Üí UserRole");
                println!("      üõí Order: {} (${:.2})", order.order_number, order.total);
                println!("      üë§ Customer: {} ({})", customer.name, customer.email);
                println!("      üè∑Ô∏è  Role: {} ({})", role.name, role.description);
                println!("      üîê Permissions: Admin={}, Products={}, Orders={}", 
                        role.permissions.system_admin,
                        role.permissions.manage_products,
                        role.permissions.manage_orders);
            }
        }
    }

    // OrderItem -> Product -> Creator chain
    if let Some(order_item) = app.store.get_order_item(1) {
        if let Some(product) = app.store.resolve_product_link(&order_item.product) {
            if let Some(creator) = app.store.resolve_user_link(&product.created_by) {
                println!("\n   üìã Traversal: OrderItem ‚Üí Product ‚Üí Creator");
                println!("      üì¶ Order Item: {}x @ ${:.2}", order_item.quantity, order_item.unit_price);
                println!("      üéØ Product: {} ({})", product.name, product.sku);
                println!("      üë®‚Äçüíª Creator: {} ({})", creator.name, creator.email);
            }
        }
    }
}

fn demonstrate_type_safety() {
    println!("\nüõ°Ô∏è  Type Safety Demonstration:");
    
    // All these relationships are enforced at compile time
    println!("   ‚úÖ OrderCustomerLink can only link to User models");
    println!("   ‚úÖ OrderItemProductLink can only link to Product models");
    println!("   ‚úÖ ProductCreatedByLink can only link to User models");
    println!("   ‚úÖ Invalid cross-definition links are caught at compile time");
    println!("   ‚úÖ Permission levels are enforced through type system");
    
    // Show that links contain type information
    let customer_link = order_def::OrderCustomerLink::new(123);
    let product_link = order_def::OrderItemProductLink::new(456);
    
    println!("\n   üîó Runtime Type Information:");
    println!("      Customer Link ‚Üí Target: {}", customer_link.target_path);
    println!("      Product Link ‚Üí Target: {}", product_link.target_path);
    println!("      Both links maintain relationship type and permission info");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cross_definition_links() {
        let mut app = EcommerceApplication::new();
        app.initialize_sample_data();

        // Test that we can resolve cross-definition relationships
        let product = app.store.get_product(1).unwrap();
        let creator = app.store.resolve_user_link(&product.created_by).unwrap();
        assert_eq!(creator.name, "Administrator");

        let order = app.store.get_order(1).unwrap();
        let customer = app.store.resolve_customer_link(&order.customer).unwrap();
        assert_eq!(customer.name, "John Doe");
    }

    #[test]
    fn test_permission_checking() {
        let link = product_def::ProductCreatedByLink::new(1);
        
        assert!(link.can_access_with_permission(&CrossDefinitionPermissionLevel::Read));
        assert!(link.can_access_with_permission(&CrossDefinitionPermissionLevel::Admin));
        assert!(!link.can_access_with_permission(&CrossDefinitionPermissionLevel::None));
    }

    #[test]
    fn test_tree_naming_standards() {
        // Verify standardized tree naming
        assert_eq!(user_def::User::MAIN_TREE_NAME, "UserDef::User::Main");
        assert_eq!(product_def::Product::MAIN_TREE_NAME, "ProductDef::Product::Main");
        assert_eq!(order_def::Order::MAIN_TREE_NAME, "OrderDef::Order::Main");

        // Verify secondary tree names are properly formatted
        assert!(user_def::User::SECONDARY_TREE_NAMES.contains(&"UserDef::User::Secondary::Email"));
        assert!(product_def::Product::SECONDARY_TREE_NAMES.contains(&"ProductDef::Product::Secondary::Sku"));
    }
}

fn main() {
    run_demo();
}