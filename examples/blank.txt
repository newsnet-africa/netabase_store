#![feature(prelude_import)]
#[macro_use]
extern crate std;
#[prelude_import]
use std::prelude::rust_2024::*;
use netabase_store::traits::model::NetabaseModelTrait;
use netabase_store::traits::store_ops::OpenTree;
use netabase_store::{NetabaseStore, netabase_definition_module};
pub mod definitions {
    use netabase_store::{NetabaseModel, netabase};
    pub struct User {
        #[primary_key]
        pub name: String,
        pub age: u8,
        #[secondary_key]
        pub email: String,
    }
    pub struct UserPrimaryKey(pub String);
    #[automatically_derived]
    impl ::core::fmt::Debug for UserPrimaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "UserPrimaryKey",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserPrimaryKey {
        #[inline]
        fn clone(&self) -> UserPrimaryKey {
            UserPrimaryKey(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserPrimaryKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserPrimaryKey {
        #[inline]
        fn eq(&self, other: &UserPrimaryKey) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserPrimaryKey {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for UserPrimaryKey {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UserPrimaryKey,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for UserPrimaryKey {
        #[inline]
        fn cmp(&self, other: &UserPrimaryKey) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserPrimaryKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(String)> for UserPrimaryKey {
        #[inline]
        fn from(value: (String)) -> Self {
            UserPrimaryKey(value)
        }
    }
    #[allow(clippy::unused_unit)]
    #[automatically_derived]
    impl derive_more::core::convert::From<UserPrimaryKey> for (String) {
        #[inline]
        fn from(value: UserPrimaryKey) -> Self {
            (<String as derive_more::core::convert::From<_>>::from(value.0))
        }
    }
    impl ::bincode::Encode for UserPrimaryKey {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            ::bincode::Encode::encode(&self.0, encoder)?;
            core::result::Result::Ok(())
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for UserPrimaryKey {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            core::result::Result::Ok(Self {
                0: ::bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context> for UserPrimaryKey {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            core::result::Result::Ok(Self {
                0: ::bincode::BorrowDecode::<'_, __Context>::borrow_decode(decoder)?,
            })
        }
    }
    pub struct UserEmailSecondaryKey(pub String);
    #[automatically_derived]
    impl ::core::fmt::Debug for UserEmailSecondaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "UserEmailSecondaryKey",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserEmailSecondaryKey {
        #[inline]
        fn clone(&self) -> UserEmailSecondaryKey {
            UserEmailSecondaryKey(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserEmailSecondaryKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserEmailSecondaryKey {
        #[inline]
        fn eq(&self, other: &UserEmailSecondaryKey) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserEmailSecondaryKey {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for UserEmailSecondaryKey {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UserEmailSecondaryKey,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for UserEmailSecondaryKey {
        #[inline]
        fn cmp(&self, other: &UserEmailSecondaryKey) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.0, &other.0)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserEmailSecondaryKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.0, state)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(String)> for UserEmailSecondaryKey {
        #[inline]
        fn from(value: (String)) -> Self {
            UserEmailSecondaryKey(value)
        }
    }
    #[allow(clippy::unused_unit)]
    #[automatically_derived]
    impl derive_more::core::convert::From<UserEmailSecondaryKey> for (String) {
        #[inline]
        fn from(value: UserEmailSecondaryKey) -> Self {
            (<String as derive_more::core::convert::From<_>>::from(value.0))
        }
    }
    impl ::bincode::Encode for UserEmailSecondaryKey {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            ::bincode::Encode::encode(&self.0, encoder)?;
            core::result::Result::Ok(())
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for UserEmailSecondaryKey {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            core::result::Result::Ok(Self {
                0: ::bincode::Decode::decode(decoder)?,
            })
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context>
    for UserEmailSecondaryKey {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            core::result::Result::Ok(Self {
                0: ::bincode::BorrowDecode::<'_, __Context>::borrow_decode(decoder)?,
            })
        }
    }
    #[strum_discriminants(
        derive(Hash, ::netabase_store::strum::Display, ::netabase_store::strum::AsRefStr)
    )]
    pub enum UserSecondaryKeys {
        Email(UserEmailSecondaryKey),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserSecondaryKeys {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserSecondaryKeys::Email(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Email",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserSecondaryKeys {
        #[inline]
        fn clone(&self) -> UserSecondaryKeys {
            match self {
                UserSecondaryKeys::Email(__self_0) => {
                    UserSecondaryKeys::Email(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserSecondaryKeys {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserSecondaryKeys {
        #[inline]
        fn eq(&self, other: &UserSecondaryKeys) -> bool {
            match (self, other) {
                (
                    UserSecondaryKeys::Email(__self_0),
                    UserSecondaryKeys::Email(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserSecondaryKeys {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<UserEmailSecondaryKey>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for UserSecondaryKeys {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UserSecondaryKeys,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match (self, other) {
                (
                    UserSecondaryKeys::Email(__self_0),
                    UserSecondaryKeys::Email(__arg1_0),
                ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for UserSecondaryKeys {
        #[inline]
        fn cmp(&self, other: &UserSecondaryKeys) -> ::core::cmp::Ordering {
            match (self, other) {
                (
                    UserSecondaryKeys::Email(__self_0),
                    UserSecondaryKeys::Email(__arg1_0),
                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserSecondaryKeys {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match self {
                UserSecondaryKeys::Email(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    pub enum UserSecondaryKeysDiscriminants {
        Email,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserSecondaryKeysDiscriminants {
        #[inline]
        fn clone(&self) -> UserSecondaryKeysDiscriminants {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for UserSecondaryKeysDiscriminants {}
    #[automatically_derived]
    impl ::core::fmt::Debug for UserSecondaryKeysDiscriminants {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Email")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserSecondaryKeysDiscriminants {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserSecondaryKeysDiscriminants {
        #[inline]
        fn eq(&self, other: &UserSecondaryKeysDiscriminants) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserSecondaryKeysDiscriminants {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserSecondaryKeysDiscriminants {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[automatically_derived]
    impl ::core::fmt::Display for UserSecondaryKeysDiscriminants {
        fn fmt(
            &self,
            f: &mut ::core::fmt::Formatter,
        ) -> ::core::result::Result<(), ::core::fmt::Error> {
            match *self {
                UserSecondaryKeysDiscriminants::Email => {
                    ::core::fmt::Display::fmt("Email", f)
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::convert::AsRef<str> for UserSecondaryKeysDiscriminants {
        #[inline]
        fn as_ref(&self) -> &str {
            match *self {
                UserSecondaryKeysDiscriminants::Email => "Email",
            }
        }
    }
    #[automatically_derived]
    impl ::strum::IntoDiscriminant for UserSecondaryKeys {
        type Discriminant = UserSecondaryKeysDiscriminants;
        #[inline]
        fn discriminant(&self) -> Self::Discriminant {
            <Self::Discriminant as ::core::convert::From<&Self>>::from(self)
        }
    }
    #[automatically_derived]
    impl ::core::convert::From<UserSecondaryKeys> for UserSecondaryKeysDiscriminants {
        #[inline]
        fn from(val: UserSecondaryKeys) -> UserSecondaryKeysDiscriminants {
            match val {
                UserSecondaryKeys::Email(..) => UserSecondaryKeysDiscriminants::Email,
            }
        }
    }
    #[automatically_derived]
    impl<'_enum> ::core::convert::From<&'_enum UserSecondaryKeys>
    for UserSecondaryKeysDiscriminants {
        #[inline]
        fn from(val: &'_enum UserSecondaryKeys) -> UserSecondaryKeysDiscriminants {
            match val {
                UserSecondaryKeys::Email(..) => UserSecondaryKeysDiscriminants::Email,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Display for UserSecondaryKeys {
        fn fmt(
            &self,
            f: &mut ::core::fmt::Formatter,
        ) -> ::core::result::Result<(), ::core::fmt::Error> {
            match *self {
                UserSecondaryKeys::Email(ref field0) => {
                    ::core::fmt::Display::fmt("Email", f)
                }
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(UserEmailSecondaryKey)>
    for UserSecondaryKeys {
        #[inline]
        fn from(value: (UserEmailSecondaryKey)) -> Self {
            UserSecondaryKeys::Email(value)
        }
    }
    #[automatically_derived]
    impl derive_more::core::convert::TryFrom<UserSecondaryKeys>
    for (UserEmailSecondaryKey) {
        type Error = derive_more::TryIntoError<UserSecondaryKeys>;
        #[inline]
        fn try_from(
            value: UserSecondaryKeys,
        ) -> derive_more::core::result::Result<
            Self,
            derive_more::TryIntoError<UserSecondaryKeys>,
        > {
            match value {
                UserSecondaryKeys::Email(__0) => {
                    derive_more::core::result::Result::Ok(__0)
                }
                _ => {
                    derive_more::core::result::Result::Err(
                        derive_more::TryIntoError::new(
                            value,
                            "Email",
                            "UserEmailSecondaryKey",
                        ),
                    )
                }
            }
        }
    }
    impl ::bincode::Encode for UserSecondaryKeys {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::Email(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for UserSecondaryKeys {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::Email {
                        0: ::bincode::Decode::<__D::Context>::decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "UserSecondaryKeys",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context>
    for UserSecondaryKeys {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::Email {
                        0: ::bincode::BorrowDecode::<
                            __D::Context,
                        >::borrow_decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "UserSecondaryKeys",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    pub enum UserKey {
        Primary(UserPrimaryKey),
        Secondary(UserSecondaryKeys),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserKey::Primary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Primary",
                        &__self_0,
                    )
                }
                UserKey::Secondary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Secondary",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserKey {
        #[inline]
        fn clone(&self) -> UserKey {
            match self {
                UserKey::Primary(__self_0) => {
                    UserKey::Primary(::core::clone::Clone::clone(__self_0))
                }
                UserKey::Secondary(__self_0) => {
                    UserKey::Secondary(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserKey {
        #[inline]
        fn eq(&self, other: &UserKey) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (UserKey::Primary(__self_0), UserKey::Primary(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (UserKey::Secondary(__self_0), UserKey::Secondary(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserKey {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<UserPrimaryKey>;
            let _: ::core::cmp::AssertParamIsEq<UserSecondaryKeys>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for UserKey {
        #[inline]
        fn partial_cmp(
            &self,
            other: &UserKey,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            match (self, other) {
                (UserKey::Primary(__self_0), UserKey::Primary(__arg1_0)) => {
                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                }
                (UserKey::Secondary(__self_0), UserKey::Secondary(__arg1_0)) => {
                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                }
                _ => ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr),
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for UserKey {
        #[inline]
        fn cmp(&self, other: &UserKey) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (UserKey::Primary(__self_0), UserKey::Primary(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (UserKey::Secondary(__self_0), UserKey::Secondary(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for UserKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state);
            match self {
                UserKey::Primary(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                UserKey::Secondary(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(UserPrimaryKey)> for UserKey {
        #[inline]
        fn from(value: (UserPrimaryKey)) -> Self {
            UserKey::Primary(value)
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(UserSecondaryKeys)> for UserKey {
        #[inline]
        fn from(value: (UserSecondaryKeys)) -> Self {
            UserKey::Secondary(value)
        }
    }
    #[automatically_derived]
    impl derive_more::core::convert::TryFrom<UserKey> for (UserPrimaryKey) {
        type Error = derive_more::TryIntoError<UserKey>;
        #[inline]
        fn try_from(
            value: UserKey,
        ) -> derive_more::core::result::Result<
            Self,
            derive_more::TryIntoError<UserKey>,
        > {
            match value {
                UserKey::Primary(__0) => derive_more::core::result::Result::Ok(__0),
                _ => {
                    derive_more::core::result::Result::Err(
                        derive_more::TryIntoError::new(
                            value,
                            "Primary",
                            "UserPrimaryKey",
                        ),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl derive_more::core::convert::TryFrom<UserKey> for (UserSecondaryKeys) {
        type Error = derive_more::TryIntoError<UserKey>;
        #[inline]
        fn try_from(
            value: UserKey,
        ) -> derive_more::core::result::Result<
            Self,
            derive_more::TryIntoError<UserKey>,
        > {
            match value {
                UserKey::Secondary(__0) => derive_more::core::result::Result::Ok(__0),
                _ => {
                    derive_more::core::result::Result::Err(
                        derive_more::TryIntoError::new(
                            value,
                            "Secondary",
                            "UserSecondaryKeys",
                        ),
                    )
                }
            }
        }
    }
    impl ::bincode::Encode for UserKey {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::Primary(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    core::result::Result::Ok(())
                }
                Self::Secondary(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(1u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for UserKey {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::Primary {
                        0: ::bincode::Decode::<__D::Context>::decode(decoder)?,
                    })
                }
                1u32 => {
                    core::result::Result::Ok(Self::Secondary {
                        0: ::bincode::Decode::<__D::Context>::decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "UserKey",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 1,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context> for UserKey {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::Primary {
                        0: ::bincode::BorrowDecode::<
                            __D::Context,
                        >::borrow_decode(decoder)?,
                    })
                }
                1u32 => {
                    core::result::Result::Ok(Self::Secondary {
                        0: ::bincode::BorrowDecode::<
                            __D::Context,
                        >::borrow_decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "UserKey",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 1,
                        },
                    })
                }
            }
        }
    }
    impl ::netabase_store::traits::model::NetabaseModelTrait<ExampleDefs> for User {
        type PrimaryKey = UserPrimaryKey;
        type SecondaryKeys = UserSecondaryKeys;
        type Keys = UserKey;
        const DISCRIMINANT: <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant = <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant::User;
        type BorrowedType<'a> = User;
        fn key(&self) -> Self::Keys {
            UserKey::Primary(self.primary_key())
        }
        fn has_secondary(&self) -> bool {
            true
        }
        fn primary_key(&self) -> Self::PrimaryKey {
            UserPrimaryKey(self.name.clone())
        }
        fn secondary_keys(
            &self,
        ) -> ::std::collections::HashMap<
            <Self::SecondaryKeys as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
            Self::SecondaryKeys,
        > {
            ::std::collections::HashMap::from([
                {
                    use ::netabase_store::strum::IntoDiscriminant;
                    let key = UserSecondaryKeys::Email(self.email.clone().into());
                    let discriminant = key.clone().into();
                    (discriminant, key)
                },
            ])
        }
        fn discriminant_name() -> &'static str {
            "User"
        }
    }
    impl ::netabase_store::traits::model::NetabaseModelTraitKey<ExampleDefs>
    for UserKey {
        type PrimaryKey = UserPrimaryKey;
        type SecondaryKey = UserSecondaryKeys;
        const DISCRIMINANT: <<ExampleDefs as ::netabase_store::traits::definition::NetabaseDefinitionTrait>::Keys as ::netabase_store::strum::IntoDiscriminant>::Discriminant = <<ExampleDefs as ::netabase_store::traits::definition::NetabaseDefinitionTrait>::Keys as ::netabase_store::strum::IntoDiscriminant>::Discriminant::UserKey;
    }
    impl ::netabase_store::netabase_deps::redb::Value for User {
        type SelfType<'a> = User where Self: 'a;
        type AsBytes<'a> = Vec<u8> where Self: 'a;
        fn fixed_width() -> Option<usize> {
            None
        }
        fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
        where
            Self: 'a,
        {
            ::netabase_store::bincode::decode_from_slice(
                    data,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
                .0
        }
        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
        where
            Self: 'a,
            Self: 'b,
        {
            ::netabase_store::bincode::encode_to_vec(
                    value,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
        }
        fn type_name() -> ::netabase_store::netabase_deps::redb::TypeName {
            ::netabase_store::netabase_deps::redb::TypeName::new("User")
        }
    }
    impl ::netabase_store::netabase_deps::redb::Value for UserPrimaryKey {
        type SelfType<'a> = UserPrimaryKey where Self: 'a;
        type AsBytes<'a> = Vec<u8> where Self: 'a;
        fn fixed_width() -> Option<usize> {
            None
        }
        fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
        where
            Self: 'a,
        {
            ::netabase_store::bincode::decode_from_slice(
                    data,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
                .0
        }
        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
        where
            Self: 'a,
            Self: 'b,
        {
            ::netabase_store::bincode::encode_to_vec(
                    value,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
        }
        fn type_name() -> ::netabase_store::netabase_deps::redb::TypeName {
            ::netabase_store::netabase_deps::redb::TypeName::new("User::PrimaryKey")
        }
    }
    impl ::netabase_store::netabase_deps::redb::Key for UserPrimaryKey {
        fn compare(data1: &[u8], data2: &[u8]) -> ::std::cmp::Ordering {
            use ::netabase_store::netabase_deps::redb::Value;
            Self::from_bytes(data1).cmp(&Self::from_bytes(data2))
        }
    }
    impl ::netabase_store::traits::model::InnerKey for UserPrimaryKey {}
    impl ::netabase_store::netabase_deps::redb::Value for UserSecondaryKeys {
        type SelfType<'a> = UserSecondaryKeys where Self: 'a;
        type AsBytes<'a> = Vec<u8> where Self: 'a;
        fn fixed_width() -> Option<usize> {
            None
        }
        fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
        where
            Self: 'a,
        {
            ::netabase_store::bincode::decode_from_slice(
                    data,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
                .0
        }
        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
        where
            Self: 'a,
            Self: 'b,
        {
            ::netabase_store::bincode::encode_to_vec(
                    value,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
        }
        fn type_name() -> ::netabase_store::netabase_deps::redb::TypeName {
            ::netabase_store::netabase_deps::redb::TypeName::new("User::SecondaryKeys")
        }
    }
    impl ::netabase_store::netabase_deps::redb::Key for UserSecondaryKeys {
        fn compare(data1: &[u8], data2: &[u8]) -> ::std::cmp::Ordering {
            use ::netabase_store::netabase_deps::redb::Value;
            Self::from_bytes(data1).cmp(&Self::from_bytes(data2))
        }
    }
    impl ::netabase_store::traits::model::InnerKey for UserSecondaryKeys {}
    impl ::netabase_store::netabase_deps::redb::Value for UserKey {
        type SelfType<'a> = UserKey where Self: 'a;
        type AsBytes<'a> = Vec<u8> where Self: 'a;
        fn fixed_width() -> Option<usize> {
            None
        }
        fn from_bytes<'a>(data: &'a [u8]) -> Self::SelfType<'a>
        where
            Self: 'a,
        {
            ::netabase_store::bincode::decode_from_slice(
                    data,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
                .0
        }
        fn as_bytes<'a, 'b: 'a>(value: &'a Self::SelfType<'b>) -> Self::AsBytes<'a>
        where
            Self: 'a,
            Self: 'b,
        {
            ::netabase_store::bincode::encode_to_vec(
                    value,
                    ::netabase_store::bincode::config::standard(),
                )
                .unwrap()
        }
        fn type_name() -> ::netabase_store::netabase_deps::redb::TypeName {
            ::netabase_store::netabase_deps::redb::TypeName::new("User::Key")
        }
    }
    impl ::netabase_store::netabase_deps::redb::Key for UserKey {
        fn compare(data1: &[u8], data2: &[u8]) -> ::std::cmp::Ordering {
            use ::netabase_store::netabase_deps::redb::Value;
            Self::from_bytes(data1).cmp(&Self::from_bytes(data2))
        }
    }
    impl ::std::borrow::Borrow<String> for UserPrimaryKey {
        fn borrow(&self) -> &String {
            &self.0
        }
    }
    impl ::std::borrow::Borrow<String> for UserEmailSecondaryKey {
        fn borrow(&self) -> &String {
            &self.0
        }
    }
    impl ::std::borrow::Borrow<UserEmailSecondaryKey> for UserSecondaryKeys {
        fn borrow(&self) -> &UserEmailSecondaryKey {
            match self {
                Self::Email(inner) => inner,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Attempted to borrow {0} from wrong SecondaryKeys variant. Use pattern matching for safe access.",
                            "UserEmailSecondaryKey",
                        ),
                    );
                }
            }
        }
    }
    impl ::std::borrow::Borrow<UserPrimaryKey> for UserKey {
        fn borrow(&self) -> &UserPrimaryKey {
            match self {
                Self::Primary(key) => key,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Attempted to borrow PrimaryKey from Secondary variant. Use pattern matching for safe access.",
                        ),
                    );
                }
            }
        }
    }
    impl ::std::borrow::Borrow<UserSecondaryKeys> for UserKey {
        fn borrow(&self) -> &UserSecondaryKeys {
            match self {
                Self::Secondary(keys) => keys,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!(
                            "Attempted to borrow SecondaryKeys from Primary variant. Use pattern matching for safe access.",
                        ),
                    );
                }
            }
        }
    }
    /// Extension trait for ergonomic secondary key construction.
    ///
    /// This trait enables convenient conversion of string values to secondary keys.
    pub trait AsUserEmail {
        /// Convert this value into a secondary key for querying.
        fn as_user_email_key(self) -> UserSecondaryKeys;
    }
    impl AsUserEmail for String {
        fn as_user_email_key(self) -> UserSecondaryKeys {
            UserSecondaryKeys::Email(UserEmailSecondaryKey(self))
        }
    }
    impl AsUserEmail for &str {
        fn as_user_email_key(self) -> UserSecondaryKeys {
            UserSecondaryKeys::Email(UserEmailSecondaryKey(self.to_string()))
        }
    }
    impl<'a> AsUserEmail for &'a String {
        fn as_user_email_key(self) -> UserSecondaryKeys {
            UserSecondaryKeys::Email(UserEmailSecondaryKey(self.clone()))
        }
    }
    #[strum_discriminants(name(ExampleDefsDiscriminant))]
    #[strum_discriminants(
        derive(
            Hash,
            ::netabase_store::strum::EnumIter,
            ::netabase_store::strum::EnumString,
            ::netabase_store::strum::AsRefStr,
            ::netabase_store::strum::Display,
            ::netabase_store::bincode::Encode,
            ::netabase_store::bincode::Decode
        )
    )]
    pub enum ExampleDefs {
        User(User),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefs {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ExampleDefs::User(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "User",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExampleDefs {
        #[inline]
        fn clone(&self) -> ExampleDefs {
            match self {
                ExampleDefs::User(__self_0) => {
                    ExampleDefs::User(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    pub enum ExampleDefsDiscriminant {
        User,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExampleDefsDiscriminant {
        #[inline]
        fn clone(&self) -> ExampleDefsDiscriminant {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ExampleDefsDiscriminant {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefsDiscriminant {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "User")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExampleDefsDiscriminant {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ExampleDefsDiscriminant {
        #[inline]
        fn eq(&self, other: &ExampleDefsDiscriminant) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ExampleDefsDiscriminant {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ExampleDefsDiscriminant {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    ///An iterator over the variants of [ExampleDefsDiscriminant]
    #[allow(missing_copy_implementations)]
    pub struct ExampleDefsDiscriminantIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<fn() -> ()>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefsDiscriminantIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ExampleDefsDiscriminantIter")
                .field("len", &self.len())
                .finish()
        }
    }
    #[automatically_derived]
    impl ExampleDefsDiscriminantIter {
        fn get(&self, idx: usize) -> ::core::option::Option<ExampleDefsDiscriminant> {
            match idx {
                0usize => ::core::option::Option::Some(ExampleDefsDiscriminant::User),
                _ => ::core::option::Option::None,
            }
        }
    }
    #[automatically_derived]
    impl ::strum::IntoEnumIterator for ExampleDefsDiscriminant {
        type Iterator = ExampleDefsDiscriminantIter;
        #[inline]
        fn iter() -> ExampleDefsDiscriminantIter {
            ExampleDefsDiscriminantIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    #[automatically_derived]
    impl Iterator for ExampleDefsDiscriminantIter {
        type Item = ExampleDefsDiscriminant;
        #[inline]
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        #[inline]
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        #[inline]
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                ExampleDefsDiscriminantIter::get(self, idx - 1)
            }
        }
    }
    #[automatically_derived]
    impl ExactSizeIterator for ExampleDefsDiscriminantIter {
        #[inline]
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    #[automatically_derived]
    impl DoubleEndedIterator for ExampleDefsDiscriminantIter {
        #[inline]
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                ExampleDefsDiscriminantIter::get(self, 1usize - self.back_idx)
            }
        }
    }
    #[automatically_derived]
    impl ::core::iter::FusedIterator for ExampleDefsDiscriminantIter {}
    #[automatically_derived]
    impl Clone for ExampleDefsDiscriminantIter {
        #[inline]
        fn clone(&self) -> ExampleDefsDiscriminantIter {
            ExampleDefsDiscriminantIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[allow(clippy::use_self)]
    #[automatically_derived]
    impl ::core::str::FromStr for ExampleDefsDiscriminant {
        type Err = ::strum::ParseError;
        #[inline]
        fn from_str(
            s: &str,
        ) -> ::core::result::Result<
            ExampleDefsDiscriminant,
            <Self as ::core::str::FromStr>::Err,
        > {
            ::core::result::Result::Ok(
                match s {
                    "User" => ExampleDefsDiscriminant::User,
                    _ => {
                        return ::core::result::Result::Err(
                            ::strum::ParseError::VariantNotFound,
                        );
                    }
                },
            )
        }
    }
    #[allow(clippy::use_self)]
    #[automatically_derived]
    impl ::core::convert::TryFrom<&str> for ExampleDefsDiscriminant {
        type Error = ::strum::ParseError;
        #[inline]
        fn try_from(
            s: &str,
        ) -> ::core::result::Result<
            ExampleDefsDiscriminant,
            <Self as ::core::convert::TryFrom<&str>>::Error,
        > {
            ::core::str::FromStr::from_str(s)
        }
    }
    #[automatically_derived]
    impl ::core::convert::AsRef<str> for ExampleDefsDiscriminant {
        #[inline]
        fn as_ref(&self) -> &str {
            match *self {
                ExampleDefsDiscriminant::User => "User",
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Display for ExampleDefsDiscriminant {
        fn fmt(
            &self,
            f: &mut ::core::fmt::Formatter,
        ) -> ::core::result::Result<(), ::core::fmt::Error> {
            match *self {
                ExampleDefsDiscriminant::User => ::core::fmt::Display::fmt("User", f),
            }
        }
    }
    impl ::bincode::Encode for ExampleDefsDiscriminant {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::User => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for ExampleDefsDiscriminant {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => core::result::Result::Ok(Self::User {}),
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefsDiscriminant",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context>
    for ExampleDefsDiscriminant {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => core::result::Result::Ok(Self::User {}),
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefsDiscriminant",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl ::strum::IntoDiscriminant for ExampleDefs {
        type Discriminant = ExampleDefsDiscriminant;
        #[inline]
        fn discriminant(&self) -> Self::Discriminant {
            <Self::Discriminant as ::core::convert::From<&Self>>::from(self)
        }
    }
    #[automatically_derived]
    impl ::core::convert::From<ExampleDefs> for ExampleDefsDiscriminant {
        #[inline]
        fn from(val: ExampleDefs) -> ExampleDefsDiscriminant {
            match val {
                ExampleDefs::User(..) => ExampleDefsDiscriminant::User,
            }
        }
    }
    #[automatically_derived]
    impl<'_enum> ::core::convert::From<&'_enum ExampleDefs> for ExampleDefsDiscriminant {
        #[inline]
        fn from(val: &'_enum ExampleDefs) -> ExampleDefsDiscriminant {
            match val {
                ExampleDefs::User(..) => ExampleDefsDiscriminant::User,
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(User)> for ExampleDefs {
        #[inline]
        fn from(value: (User)) -> Self {
            ExampleDefs::User(value)
        }
    }
    #[automatically_derived]
    impl derive_more::core::convert::TryFrom<ExampleDefs> for (User) {
        type Error = derive_more::TryIntoError<ExampleDefs>;
        #[inline]
        fn try_from(
            value: ExampleDefs,
        ) -> derive_more::core::result::Result<
            Self,
            derive_more::TryIntoError<ExampleDefs>,
        > {
            match value {
                ExampleDefs::User(__0) => derive_more::core::result::Result::Ok(__0),
                _ => {
                    derive_more::core::result::Result::Err(
                        derive_more::TryIntoError::new(value, "User", "User"),
                    )
                }
            }
        }
    }
    impl ::bincode::Encode for ExampleDefs {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::User(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for ExampleDefs {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::User {
                        0: ::bincode::Decode::<__D::Context>::decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefs",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context> for ExampleDefs {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::User {
                        0: ::bincode::BorrowDecode::<
                            __D::Context,
                        >::borrow_decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefs",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ExampleDefs {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private228::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ExampleDefs::User(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ExampleDefs",
                            0u32,
                            "User",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ExampleDefs {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private228::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private228::Ok(__Field::__field0),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "User" => _serde::__private228::Ok(__Field::__field0),
                            _ => {
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private228::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"User" => _serde::__private228::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private228::from_utf8_lossy(
                                    __value,
                                );
                                _serde::__private228::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private228::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private228::PhantomData<ExampleDefs>,
                    lifetime: _serde::__private228::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ExampleDefs;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private228::Formatter,
                    ) -> _serde::__private228::fmt::Result {
                        _serde::__private228::Formatter::write_str(
                            __formatter,
                            "enum ExampleDefs",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private228::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private228::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        User,
                                    >(__variant),
                                    ExampleDefs::User,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["User"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ExampleDefs",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private228::PhantomData::<ExampleDefs>,
                        lifetime: _serde::__private228::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Display for ExampleDefs {
        fn fmt(
            &self,
            f: &mut ::core::fmt::Formatter,
        ) -> ::core::result::Result<(), ::core::fmt::Error> {
            match *self {
                ExampleDefs::User(ref field0) => ::core::fmt::Display::fmt("User", f),
            }
        }
    }
    #[strum_discriminants(name(ExampleDefKeysDiscriminant))]
    #[strum_discriminants(
        derive(
            Hash,
            ::netabase_store::strum::EnumIter,
            ::netabase_store::strum::EnumString,
            ::netabase_store::strum::AsRefStr,
            ::netabase_store::strum::Display,
            ::netabase_store::bincode::Encode,
            ::netabase_store::bincode::Decode
        )
    )]
    pub enum ExampleDefKeys {
        UserKey(UserKey),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefKeys {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ExampleDefKeys::UserKey(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UserKey",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExampleDefKeys {
        #[inline]
        fn clone(&self) -> ExampleDefKeys {
            match self {
                ExampleDefKeys::UserKey(__self_0) => {
                    ExampleDefKeys::UserKey(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExampleDefKeys {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ExampleDefKeys {
        #[inline]
        fn eq(&self, other: &ExampleDefKeys) -> bool {
            match (self, other) {
                (
                    ExampleDefKeys::UserKey(__self_0),
                    ExampleDefKeys::UserKey(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ExampleDefKeys {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<UserKey>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ExampleDefKeys {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ExampleDefKeys,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match (self, other) {
                (
                    ExampleDefKeys::UserKey(__self_0),
                    ExampleDefKeys::UserKey(__arg1_0),
                ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ExampleDefKeys {
        #[inline]
        fn cmp(&self, other: &ExampleDefKeys) -> ::core::cmp::Ordering {
            match (self, other) {
                (
                    ExampleDefKeys::UserKey(__self_0),
                    ExampleDefKeys::UserKey(__arg1_0),
                ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ExampleDefKeys {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match self {
                ExampleDefKeys::UserKey(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
            }
        }
    }
    pub enum ExampleDefKeysDiscriminant {
        UserKey,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExampleDefKeysDiscriminant {
        #[inline]
        fn clone(&self) -> ExampleDefKeysDiscriminant {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ExampleDefKeysDiscriminant {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefKeysDiscriminant {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UserKey")
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExampleDefKeysDiscriminant {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ExampleDefKeysDiscriminant {
        #[inline]
        fn eq(&self, other: &ExampleDefKeysDiscriminant) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ExampleDefKeysDiscriminant {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ExampleDefKeysDiscriminant {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    ///An iterator over the variants of [ExampleDefKeysDiscriminant]
    #[allow(missing_copy_implementations)]
    pub struct ExampleDefKeysDiscriminantIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<fn() -> ()>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ExampleDefKeysDiscriminantIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ExampleDefKeysDiscriminantIter")
                .field("len", &self.len())
                .finish()
        }
    }
    #[automatically_derived]
    impl ExampleDefKeysDiscriminantIter {
        fn get(&self, idx: usize) -> ::core::option::Option<ExampleDefKeysDiscriminant> {
            match idx {
                0usize => {
                    ::core::option::Option::Some(ExampleDefKeysDiscriminant::UserKey)
                }
                _ => ::core::option::Option::None,
            }
        }
    }
    #[automatically_derived]
    impl ::strum::IntoEnumIterator for ExampleDefKeysDiscriminant {
        type Iterator = ExampleDefKeysDiscriminantIter;
        #[inline]
        fn iter() -> ExampleDefKeysDiscriminantIter {
            ExampleDefKeysDiscriminantIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    #[automatically_derived]
    impl Iterator for ExampleDefKeysDiscriminantIter {
        type Item = ExampleDefKeysDiscriminant;
        #[inline]
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        #[inline]
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        #[inline]
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                ExampleDefKeysDiscriminantIter::get(self, idx - 1)
            }
        }
    }
    #[automatically_derived]
    impl ExactSizeIterator for ExampleDefKeysDiscriminantIter {
        #[inline]
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    #[automatically_derived]
    impl DoubleEndedIterator for ExampleDefKeysDiscriminantIter {
        #[inline]
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                ExampleDefKeysDiscriminantIter::get(self, 1usize - self.back_idx)
            }
        }
    }
    #[automatically_derived]
    impl ::core::iter::FusedIterator for ExampleDefKeysDiscriminantIter {}
    #[automatically_derived]
    impl Clone for ExampleDefKeysDiscriminantIter {
        #[inline]
        fn clone(&self) -> ExampleDefKeysDiscriminantIter {
            ExampleDefKeysDiscriminantIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[allow(clippy::use_self)]
    #[automatically_derived]
    impl ::core::str::FromStr for ExampleDefKeysDiscriminant {
        type Err = ::strum::ParseError;
        #[inline]
        fn from_str(
            s: &str,
        ) -> ::core::result::Result<
            ExampleDefKeysDiscriminant,
            <Self as ::core::str::FromStr>::Err,
        > {
            ::core::result::Result::Ok(
                match s {
                    "UserKey" => ExampleDefKeysDiscriminant::UserKey,
                    _ => {
                        return ::core::result::Result::Err(
                            ::strum::ParseError::VariantNotFound,
                        );
                    }
                },
            )
        }
    }
    #[allow(clippy::use_self)]
    #[automatically_derived]
    impl ::core::convert::TryFrom<&str> for ExampleDefKeysDiscriminant {
        type Error = ::strum::ParseError;
        #[inline]
        fn try_from(
            s: &str,
        ) -> ::core::result::Result<
            ExampleDefKeysDiscriminant,
            <Self as ::core::convert::TryFrom<&str>>::Error,
        > {
            ::core::str::FromStr::from_str(s)
        }
    }
    #[automatically_derived]
    impl ::core::convert::AsRef<str> for ExampleDefKeysDiscriminant {
        #[inline]
        fn as_ref(&self) -> &str {
            match *self {
                ExampleDefKeysDiscriminant::UserKey => "UserKey",
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Display for ExampleDefKeysDiscriminant {
        fn fmt(
            &self,
            f: &mut ::core::fmt::Formatter,
        ) -> ::core::result::Result<(), ::core::fmt::Error> {
            match *self {
                ExampleDefKeysDiscriminant::UserKey => {
                    ::core::fmt::Display::fmt("UserKey", f)
                }
            }
        }
    }
    impl ::bincode::Encode for ExampleDefKeysDiscriminant {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::UserKey => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for ExampleDefKeysDiscriminant {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => core::result::Result::Ok(Self::UserKey {}),
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefKeysDiscriminant",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context>
    for ExampleDefKeysDiscriminant {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => core::result::Result::Ok(Self::UserKey {}),
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefKeysDiscriminant",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl ::strum::IntoDiscriminant for ExampleDefKeys {
        type Discriminant = ExampleDefKeysDiscriminant;
        #[inline]
        fn discriminant(&self) -> Self::Discriminant {
            <Self::Discriminant as ::core::convert::From<&Self>>::from(self)
        }
    }
    #[automatically_derived]
    impl ::core::convert::From<ExampleDefKeys> for ExampleDefKeysDiscriminant {
        #[inline]
        fn from(val: ExampleDefKeys) -> ExampleDefKeysDiscriminant {
            match val {
                ExampleDefKeys::UserKey(..) => ExampleDefKeysDiscriminant::UserKey,
            }
        }
    }
    #[automatically_derived]
    impl<'_enum> ::core::convert::From<&'_enum ExampleDefKeys>
    for ExampleDefKeysDiscriminant {
        #[inline]
        fn from(val: &'_enum ExampleDefKeys) -> ExampleDefKeysDiscriminant {
            match val {
                ExampleDefKeys::UserKey(..) => ExampleDefKeysDiscriminant::UserKey,
            }
        }
    }
    #[allow(unreachable_code)]
    #[automatically_derived]
    impl derive_more::core::convert::From<(UserKey)> for ExampleDefKeys {
        #[inline]
        fn from(value: (UserKey)) -> Self {
            ExampleDefKeys::UserKey(value)
        }
    }
    #[automatically_derived]
    impl derive_more::core::convert::TryFrom<ExampleDefKeys> for (UserKey) {
        type Error = derive_more::TryIntoError<ExampleDefKeys>;
        #[inline]
        fn try_from(
            value: ExampleDefKeys,
        ) -> derive_more::core::result::Result<
            Self,
            derive_more::TryIntoError<ExampleDefKeys>,
        > {
            match value {
                ExampleDefKeys::UserKey(__0) => {
                    derive_more::core::result::Result::Ok(__0)
                }
                _ => {
                    derive_more::core::result::Result::Err(
                        derive_more::TryIntoError::new(value, "UserKey", "UserKey"),
                    )
                }
            }
        }
    }
    impl ::bincode::Encode for ExampleDefKeys {
        fn encode<__E: ::bincode::enc::Encoder>(
            &self,
            encoder: &mut __E,
        ) -> core::result::Result<(), ::bincode::error::EncodeError> {
            match self {
                Self::UserKey(field_0) => {
                    <u32 as ::bincode::Encode>::encode(&(0u32), encoder)?;
                    ::bincode::Encode::encode(field_0, encoder)?;
                    core::result::Result::Ok(())
                }
            }
        }
    }
    impl<__Context> ::bincode::Decode<__Context> for ExampleDefKeys {
        fn decode<__D: ::bincode::de::Decoder<Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::UserKey {
                        0: ::bincode::Decode::<__D::Context>::decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefKeys",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    impl<'__de, __Context> ::bincode::BorrowDecode<'__de, __Context> for ExampleDefKeys {
        fn borrow_decode<__D: ::bincode::de::BorrowDecoder<'__de, Context = __Context>>(
            decoder: &mut __D,
        ) -> core::result::Result<Self, ::bincode::error::DecodeError> {
            let variant_index = <u32 as ::bincode::Decode<
                __D::Context,
            >>::decode(decoder)?;
            match variant_index {
                0u32 => {
                    core::result::Result::Ok(Self::UserKey {
                        0: ::bincode::BorrowDecode::<
                            __D::Context,
                        >::borrow_decode(decoder)?,
                    })
                }
                variant => {
                    core::result::Result::Err(::bincode::error::DecodeError::UnexpectedVariant {
                        found: variant,
                        type_name: "ExampleDefKeys",
                        allowed: &::bincode::error::AllowedEnumVariants::Range {
                            min: 0,
                            max: 0,
                        },
                    })
                }
            }
        }
    }
    pub struct ExampleDefsTables {
        pub user: ::netabase_store::redb::TableDefinition<
            'static,
            ::netabase_store::databases::redb_store::BincodeWrapper<UserPrimaryKey>,
            ::netabase_store::databases::redb_store::BincodeWrapper<User>,
        >,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExampleDefsTables {
        #[inline]
        fn clone(&self) -> ExampleDefsTables {
            let _: ::core::clone::AssertParamIsClone<
                ::netabase_store::redb::TableDefinition<
                    'static,
                    ::netabase_store::databases::redb_store::BincodeWrapper<
                        UserPrimaryKey,
                    >,
                    ::netabase_store::databases::redb_store::BincodeWrapper<User>,
                >,
            >;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ExampleDefsTables {}
    const _: () = {
        fn assert_discriminant<
            T: ::netabase_store::traits::definition::NetabaseDiscriminant,
        >() {}
        fn assert_key_discriminant<
            T: ::netabase_store::traits::definition::NetabaseKeyDiscriminant,
        >() {}
        fn _check() {
            assert_discriminant::<ExampleDefsDiscriminant>();
            assert_key_discriminant::<ExampleDefKeysDiscriminant>();
        }
    };
}
mod __exampledefs_helpers {
    use super::*;
    pub(super) use decode_record_key;
}
/// Generic records iterator for sled stores
pub fn record_store_records_sled(
    store: &::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
) -> RecordsIterGenerated<'_> {
    RecordsIterGenerated::new(store)
}
/// Generic add_provider for sled stores
pub fn record_store_add_provider_sled(
    store: &mut ::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
    record: ::libp2p::kad::ProviderRecord,
) -> ::libp2p::kad::store::Result<()> {
    store.add_provider_internal(record)
}
/// Generic providers for sled stores
pub fn record_store_providers_sled(
    store: &::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
    key: &::libp2p::kad::RecordKey,
) -> Vec<::libp2p::kad::ProviderRecord> {
    store.providers_internal(key).unwrap_or_default()
}
/// Generic provided for sled stores
pub fn record_store_provided_sled(
    store: &::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
) -> ProvidedIterGenerated<'_> {
    ProvidedIterGenerated::new(store)
}
/// Generic remove_provider for sled stores
pub fn record_store_remove_provider_sled(
    store: &mut ::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
    key: &::libp2p::kad::RecordKey,
    provider: &::libp2p::PeerId,
) {
    store.remove_provider_internal(key, provider)
}
/// Generic add_provider for redb stores
pub fn record_store_add_provider_redb(
    store: &mut ::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
    record: ::libp2p::kad::ProviderRecord,
) -> ::libp2p::kad::store::Result<()> {
    store.add_provider_internal(record)
}
/// Generic providers for redb stores
pub fn record_store_providers_redb(
    store: &::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
    key: &::libp2p::kad::RecordKey,
) -> Vec<::libp2p::kad::ProviderRecord> {
    store.providers_internal(key).unwrap_or_default()
}
/// Generic provided for redb stores
pub fn record_store_provided_redb(
    store: &::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
) -> ProvidedIterRedb<'_> {
    ProvidedIterRedb::new(store)
}
/// Generic remove_provider for redb stores
pub fn record_store_remove_provider_redb(
    store: &mut ::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
    key: &::libp2p::kad::RecordKey,
    provider: &::libp2p::PeerId,
) {
    store.remove_provider_internal(key, provider)
}
/// Generic records for redb stores
pub fn record_store_records_redb(
    store: &::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
) -> RecordsIterRedb<'_> {
    RecordsIterRedb::new(store)
}
pub struct RecordsIterGenerated<'a> {
    discriminants: Vec<
        <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
    >,
    current_discriminant_index: usize,
    current_tree_iter: Option<::sled::Iter>,
    store: &'a ::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
}
impl<'a> RecordsIterGenerated<'a> {
    fn new(
        store: &'a ::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
    ) -> Self {
        use ::netabase_store::strum::IntoEnumIterator;
        let discriminants: Vec<_> = <<ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant as IntoEnumIterator>::iter()
            .collect();
        RecordsIterGenerated {
            discriminants,
            current_discriminant_index: 0,
            current_tree_iter: None,
            store,
        }
    }
}
impl<'a> Iterator for RecordsIterGenerated<'a> {
    type Item = std::borrow::Cow<'a, ::libp2p::kad::Record>;
    fn next(&mut self) -> Option<Self::Item> {
        use ::netabase_store::strum::IntoDiscriminant;
        loop {
            if self.current_tree_iter.is_none() {
                if self.current_discriminant_index >= self.discriminants.len() {
                    return None;
                }
                let disc = &self.discriminants[self.current_discriminant_index];
                if let Ok(tree) = self.store.db().open_tree(disc.to_string()) {
                    self.current_tree_iter = Some(tree.iter());
                } else {
                    self.current_discriminant_index += 1;
                    continue;
                }
            }
            if let Some(ref mut iter) = self.current_tree_iter {
                match iter.next() {
                    Some(Ok((_key_bytes, value_bytes))) => {
                        let disc = &self.discriminants[self.current_discriminant_index];
                        match disc {
                            disc if disc.to_string() == "User" => {
                                if let Ok((model, _)) = ::netabase_store::bincode::decode_from_slice::<
                                    User,
                                    _,
                                >(
                                    &value_bytes,
                                    ::netabase_store::bincode::config::standard(),
                                ) {
                                    use ::netabase_store::traits::model::NetabaseModelTrait;
                                    let primary_key = model.primary_key();
                                    let model_key = UserKey::Primary(primary_key);
                                    let def_keys = ExampleDefKeys::UserKey(model_key);
                                    if let Ok(key_bytes) = ::netabase_store::bincode::encode_to_vec(
                                        &def_keys,
                                        ::netabase_store::bincode::config::standard(),
                                    ) {
                                        let definition = ExampleDefs::User(model);
                                        if let Ok(value) = ::netabase_store::bincode::encode_to_vec(
                                            &definition,
                                            ::netabase_store::bincode::config::standard(),
                                        ) {
                                            return Some(
                                                std::borrow::Cow::Owned(::libp2p::kad::Record {
                                                    key: ::libp2p::kad::RecordKey::from(key_bytes),
                                                    value,
                                                    publisher: None,
                                                    expires: None,
                                                }),
                                            );
                                        }
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    Some(Err(_)) => continue,
                    None => {
                        self.current_tree_iter = None;
                        self.current_discriminant_index += 1;
                        continue;
                    }
                }
            }
        }
    }
}
pub struct ProvidedIterGenerated<'a> {
    inner: ::sled::Iter,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> ProvidedIterGenerated<'a> {
    fn new(
        store: &'a ::netabase_store::databases::sled_store::SledStore<ExampleDefs>,
    ) -> Self {
        let tree = store
            .db()
            .open_tree("__libp2p_provided")
            .expect("Failed to open provided tree");
        ProvidedIterGenerated {
            inner: tree.iter(),
            _phantom: std::marker::PhantomData,
        }
    }
}
impl<'a> Iterator for ProvidedIterGenerated<'a> {
    type Item = std::borrow::Cow<'a, ::libp2p::kad::ProviderRecord>;
    fn next(&mut self) -> Option<Self::Item> {
        self.inner
            .next()
            .and_then(|result| {
                result
                    .ok()
                    .and_then(|(_, v)| {
                        use ::netabase_store::databases::record_store::utils::decode_provider;
                        decode_provider(&v).ok().map(std::borrow::Cow::Owned)
                    })
            })
    }
}
pub struct RecordsIterRedb<'a> {
    records: std::vec::IntoIter<::libp2p::kad::Record>,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> RecordsIterRedb<'a> {
    fn new(
        store: &'a ::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
    ) -> Self {
        use ::netabase_store::strum::IntoEnumIterator;
        use ::netabase_store::strum::IntoDiscriminant;
        use ::netabase_store::redb::{ReadableDatabase, ReadableTable};
        let mut records = Vec::new();
        let discriminants: Vec<_> = <<ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant as IntoEnumIterator>::iter()
            .collect();
        if let Ok(read_txn) = store.db().begin_read() {
            for disc in discriminants {
                let table_name = disc.to_string();
                let static_name: &'static str = Box::leak(table_name.into_boxed_str());
                let table_def = ::netabase_store::redb::TableDefinition::<
                    &[u8],
                    &[u8],
                >::new(static_name);
                if let Ok(table) = read_txn.open_table(table_def) {
                    if let Ok(iter) = table.iter() {
                        for item in iter {
                            if let Ok((k, v)) = item {
                                let _key_bytes = k.value();
                                let value_bytes = v.value();
                                match disc {
                                    disc if disc.to_string() == "User" => {
                                        if let Ok((model, _)) = ::netabase_store::bincode::decode_from_slice::<
                                            User,
                                            _,
                                        >(
                                            &value_bytes,
                                            ::netabase_store::bincode::config::standard(),
                                        ) {
                                            use ::netabase_store::traits::model::NetabaseModelTrait;
                                            let primary_key = model.primary_key();
                                            let model_key = UserKey::Primary(primary_key);
                                            let def_keys = ExampleDefKeys::UserKey(model_key);
                                            if let Ok(key_bytes) = ::netabase_store::bincode::encode_to_vec(
                                                &def_keys,
                                                ::netabase_store::bincode::config::standard(),
                                            ) {
                                                let definition = ExampleDefs::User(model);
                                                if let Ok(value) = ::netabase_store::bincode::encode_to_vec(
                                                    &definition,
                                                    ::netabase_store::bincode::config::standard(),
                                                ) {
                                                    records
                                                        .push(::libp2p::kad::Record {
                                                            key: ::libp2p::kad::RecordKey::from(key_bytes),
                                                            value,
                                                            publisher: None,
                                                            expires: None,
                                                        });
                                                }
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                }
            }
        }
        RecordsIterRedb {
            records: records.into_iter(),
            _phantom: std::marker::PhantomData,
        }
    }
}
impl<'a> Iterator for RecordsIterRedb<'a> {
    type Item = std::borrow::Cow<'a, ::libp2p::kad::Record>;
    fn next(&mut self) -> Option<Self::Item> {
        self.records.next().map(std::borrow::Cow::Owned)
    }
}
pub struct ProvidedIterRedb<'a> {
    records: std::vec::IntoIter<::libp2p::kad::ProviderRecord>,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> ProvidedIterRedb<'a> {
    fn new(
        store: &'a ::netabase_store::databases::redb_store::RedbStore<ExampleDefs>,
    ) -> Self {
        use ::netabase_store::redb::{ReadableDatabase, ReadableTable};
        let mut records = Vec::new();
        if let Ok(read_txn) = store.db().begin_read() {
            let table_def = ::netabase_store::redb::TableDefinition::<
                &[u8],
                &[u8],
            >::new("__libp2p_provided");
            if let Ok(table) = read_txn.open_table(table_def) {
                if let Ok(iter) = table.iter() {
                    for item in iter {
                        if let Ok((_, v)) = item {
                            use ::netabase_store::databases::record_store::utils::decode_provider;
                            if let Ok(provider) = decode_provider(v.value()) {
                                records.push(provider);
                            }
                        }
                    }
                }
            }
        }
        ProvidedIterRedb {
            records: records.into_iter(),
            _phantom: std::marker::PhantomData,
        }
    }
}
impl<'a> Iterator for ProvidedIterRedb<'a> {
    type Item = std::borrow::Cow<'a, ::libp2p::kad::ProviderRecord>;
    fn next(&mut self) -> Option<Self::Item> {
        self.records.next().map(std::borrow::Cow::Owned)
    }
}
impl ::netabase_store::traits::definition::NetabaseDefinitionTrait for ExampleDefs {
    type Keys = ExampleDefKeys;
    type Tables = ExampleDefsTables;
    fn tables() -> Self::Tables {
        ExampleDefsTables::new()
    }
}
impl ::netabase_store::traits::definition::RecordStoreExt for ExampleDefs {
    fn handle_sled_put(
        &self,
        store: &::netabase_store::databases::sled_store::SledStore<Self>,
    ) -> ::libp2p::kad::store::Result<()>
    where
        Self: Sized,
    {
        use ::libp2p::kad::store::Error;
        use ::netabase_store::traits::store_ops::StoreOps;
        match self {
            Self::User(model) => {
                let tree = store.open_tree::<User>();
                tree.put_raw(model.clone()).map_err(|_| Error::MaxRecords)?;
                return Ok(());
            }
        }
        Err(Error::MaxRecords)
    }
    fn handle_sled_get(
        store: &::netabase_store::databases::sled_store::SledStore<Self>,
        key: &::libp2p::kad::RecordKey,
    ) -> Option<(Self, ::libp2p::kad::Record)>
    where
        Self: Sized,
    {
        use ::netabase_store::traits::definition::NetabaseDefinitionTrait;
        use ::netabase_store::traits::store_ops::StoreOps;
        use ::netabase_store::strum::IntoDiscriminant;
        let (discriminant, key_bytes) = {
            (|| -> Option<
                (
                    <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
                    Vec<u8>,
                ),
            > {
                let bytes = key.to_vec();
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let disc_str = match &def_keys {
                    ExampleDefKeys::UserKey(_) => "User",
                };
                let discriminant: <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant = disc_str
                    .parse()
                    .ok()?;
                let key_bytes = ::netabase_store::bincode::encode_to_vec(
                        &def_keys,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                Some((discriminant, key_bytes))
            })()
        }?;
        match discriminant {
            disc if disc.to_string() == "User" => {
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &key_bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let model_key = match def_keys {
                    ExampleDefKeys::UserKey(k) => k,
                    _ => return None,
                };
                let primary_key = match model_key {
                    UserKey::Primary(pk) => pk,
                    _ => return None,
                };
                let tree = store.open_tree::<User>();
                let model = tree.get_raw(primary_key).ok()??;
                let definition = ExampleDefs::User(model);
                let value = ::netabase_store::bincode::encode_to_vec(
                        &definition,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                return Some((
                    definition.clone(),
                    ::libp2p::kad::Record {
                        key: key.clone(),
                        value,
                        publisher: None,
                        expires: None,
                    },
                ));
            }
            _ => {}
        }
        None
    }
    fn handle_sled_remove(
        store: &::netabase_store::databases::sled_store::SledStore<Self>,
        key: &::libp2p::kad::RecordKey,
    )
    where
        Self: Sized,
    {
        use ::netabase_store::traits::definition::NetabaseDefinitionTrait;
        use ::netabase_store::traits::store_ops::StoreOps;
        use ::netabase_store::strum::IntoDiscriminant;
        if let Some((discriminant, key_bytes)) = {
            (|| -> Option<
                (
                    <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
                    Vec<u8>,
                ),
            > {
                let bytes = key.to_vec();
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let disc_str = match &def_keys {
                    ExampleDefKeys::UserKey(_) => "User",
                };
                let discriminant: <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant = disc_str
                    .parse()
                    .ok()?;
                let key_bytes = ::netabase_store::bincode::encode_to_vec(
                        &def_keys,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                Some((discriminant, key_bytes))
            })()
        } {
            match discriminant {
                disc if disc.to_string() == "User" => {
                    if let Ok((def_keys, _)) = ::netabase_store::bincode::decode_from_slice::<
                        ExampleDefKeys,
                        _,
                    >(&key_bytes, ::netabase_store::bincode::config::standard()) {
                        if let ExampleDefKeys::UserKey(model_key) = def_keys {
                            if let UserKey::Primary(primary_key) = model_key {
                                let tree = store.open_tree::<User>();
                                let _ = tree.remove_raw(primary_key);
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }
    fn handle_sled_records<'a>(
        store: &'a ::netabase_store::databases::sled_store::SledStore<Self>,
    ) -> Box<dyn Iterator<Item = std::borrow::Cow<'a, ::libp2p::kad::Record>> + 'a>
    where
        Self: Sized,
    {
        Box::new(RecordsIterGenerated::new(store))
    }
    fn handle_redb_put(
        &self,
        store: &::netabase_store::databases::redb_store::RedbStore<Self>,
    ) -> ::libp2p::kad::store::Result<()>
    where
        Self: Sized,
    {
        use ::libp2p::kad::store::Error;
        use ::netabase_store::traits::store_ops::StoreOps;
        match self {
            Self::User(model) => {
                let tree = store.open_tree::<User>();
                tree.put_raw(model.clone()).map_err(|_| Error::MaxRecords)?;
                return Ok(());
            }
        }
        Err(Error::MaxRecords)
    }
    fn handle_redb_get(
        store: &::netabase_store::databases::redb_store::RedbStore<Self>,
        key: &::libp2p::kad::RecordKey,
    ) -> Option<(Self, ::libp2p::kad::Record)>
    where
        Self: Sized,
    {
        use ::netabase_store::traits::definition::NetabaseDefinitionTrait;
        use ::netabase_store::traits::store_ops::StoreOps;
        use ::netabase_store::strum::IntoDiscriminant;
        let (discriminant, key_bytes) = {
            (|| -> Option<
                (
                    <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
                    Vec<u8>,
                ),
            > {
                let bytes = key.to_vec();
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let disc_str = match &def_keys {
                    ExampleDefKeys::UserKey(_) => "User",
                };
                let discriminant: <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant = disc_str
                    .parse()
                    .ok()?;
                let key_bytes = ::netabase_store::bincode::encode_to_vec(
                        &def_keys,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                Some((discriminant, key_bytes))
            })()
        }?;
        match discriminant {
            disc if disc.to_string() == "User" => {
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &key_bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let model_key = match def_keys {
                    ExampleDefKeys::UserKey(k) => k,
                    _ => return None,
                };
                let primary_key = match model_key {
                    UserKey::Primary(pk) => pk,
                    _ => return None,
                };
                let tree = store.open_tree::<User>();
                let model = tree.get_raw(primary_key).ok()??;
                let definition = ExampleDefs::User(model);
                let value = ::netabase_store::bincode::encode_to_vec(
                        &definition,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                return Some((
                    definition.clone(),
                    ::libp2p::kad::Record {
                        key: key.clone(),
                        value,
                        publisher: None,
                        expires: None,
                    },
                ));
            }
            _ => {}
        }
        None
    }
    fn handle_redb_remove(
        store: &::netabase_store::databases::redb_store::RedbStore<Self>,
        key: &::libp2p::kad::RecordKey,
    )
    where
        Self: Sized,
    {
        use ::netabase_store::traits::definition::NetabaseDefinitionTrait;
        use ::netabase_store::traits::store_ops::StoreOps;
        use ::netabase_store::strum::IntoDiscriminant;
        if let Some((discriminant, key_bytes)) = {
            (|| -> Option<
                (
                    <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant,
                    Vec<u8>,
                ),
            > {
                let bytes = key.to_vec();
                let (def_keys, _): (ExampleDefKeys, _) = ::netabase_store::bincode::decode_from_slice(
                        &bytes,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                let disc_str = match &def_keys {
                    ExampleDefKeys::UserKey(_) => "User",
                };
                let discriminant: <ExampleDefs as ::netabase_store::strum::IntoDiscriminant>::Discriminant = disc_str
                    .parse()
                    .ok()?;
                let key_bytes = ::netabase_store::bincode::encode_to_vec(
                        &def_keys,
                        ::netabase_store::bincode::config::standard(),
                    )
                    .ok()?;
                Some((discriminant, key_bytes))
            })()
        } {
            match discriminant {
                disc if disc.to_string() == "User" => {
                    if let Ok((def_keys, _)) = ::netabase_store::bincode::decode_from_slice::<
                        ExampleDefKeys,
                        _,
                    >(&key_bytes, ::netabase_store::bincode::config::standard()) {
                        if let ExampleDefKeys::UserKey(model_key) = def_keys {
                            if let UserKey::Primary(primary_key) = model_key {
                                let tree = store.open_tree::<User>();
                                let _ = tree.remove_raw(primary_key);
                            }
                        }
                    }
                }
                _ => {}
            }
        }
    }
    fn handle_redb_records<'a>(
        store: &'a ::netabase_store::databases::redb_store::RedbStore<Self>,
    ) -> Box<dyn Iterator<Item = std::borrow::Cow<'a, ::libp2p::kad::Record>> + 'a>
    where
        Self: Sized,
    {
        Box::new(RecordsIterRedb::new(store))
    }
}
impl ::netabase_store::traits::definition::NetabaseDefinitionTraitKey
for ExampleDefKeys {}
impl ::netabase_store::traits::convert::ToIVec for ExampleDefs {}
impl ::netabase_store::traits::convert::ToIVec for ExampleDefKeys {}
impl ::std::convert::AsRef<User> for ExampleDefs {
    fn as_ref(&self) -> &User {
        match self {
            Self::User(model) => model,
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Attempted to access {0} from wrong variant. Use TryInto for safe variant access.",
                        "User",
                    ),
                );
            }
        }
    }
}
impl ::std::borrow::Borrow<User> for ExampleDefs {
    fn borrow(&self) -> &User {
        match self {
            Self::User(model) => model,
            _ => {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "Attempted to borrow {0} from wrong variant. Use TryInto for safe variant access.",
                        "User",
                    ),
                );
            }
        }
    }
}
impl ExampleDefsTables {
    /// Create a new tables definition with all table names initialized
    ///
    /// This is a const function so it can be used in static contexts.
    pub const fn new() -> Self {
        Self {
            user: ::netabase_store::redb::TableDefinition::new("user"),
        }
    }
}
use definitions::*;
