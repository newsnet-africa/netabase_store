#[cfg(feature = "paxos")]
use paxakos::LogEntry;
use std::str::FromStr;

#[cfg(feature = "paxos")]
use crate::error::NetabaseError;
use crate::{MaybeSend, MaybeSync};
use strum::IntoDiscriminant;

/// A consolidated trait for all discriminant bounds used throughout netabase.
///
/// This trait encapsulates all the common bounds required for discriminants,
/// allowing simpler trait bounds like `D::Discriminant: NetabaseDiscriminant`
/// instead of repeating all bounds everywhere.
pub trait NetabaseDiscriminant:
    AsRef<str>
    + Clone
    + Copy
    + std::fmt::Debug
    + std::fmt::Display
    + PartialEq
    + Eq
    + std::hash::Hash
    + strum::IntoEnumIterator
    + MaybeSend
    + MaybeSync
    + 'static
    + FromStr
    + bincode::Encode
    + bincode::Decode<()>
{
}

// Blanket implementation for any type that satisfies the bounds
impl<T> NetabaseDiscriminant for T where
    T: AsRef<str>
        + Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr
        + bincode::Encode
        + bincode::Decode<()>
{
}

/// A consolidated trait for key discriminant bounds.
///
/// Similar to `NetabaseDiscriminant` but with fewer bounds (no `AsRef<str>`, Display, or FromStr)
/// since key discriminants don't need string conversion capabilities.
pub trait NetabaseKeyDiscriminant:
    Clone
    + Copy
    + std::fmt::Debug
    + PartialEq
    + Eq
    + std::hash::Hash
    + MaybeSend
    + MaybeSync
    + 'static
    + bincode::Encode
    + bincode::Decode<()>
{
}

// Blanket implementation for any type that satisfies the bounds
impl<T> NetabaseKeyDiscriminant for T where
    T: Clone
        + Copy
        + std::fmt::Debug
        + PartialEq
        + Eq
        + std::hash::Hash
        + MaybeSend
        + MaybeSync
        + 'static
        + bincode::Encode
        + bincode::Decode<()>
{
}

/// Trait for the module-level definition enum that wraps all models.
///
/// This trait is automatically implemented by the `#[netabase_definition_module]` macro.
/// The definition enum is used as the primary type for encoding, decoding, and moving
/// model data around.
///
/// # Simplified Bounds
///
/// This trait now uses `NetabaseDiscriminant` and `NetabaseKeyDiscriminant` to consolidate
/// the many trait bounds previously repeated everywhere. This means you can simply write:
///
/// ```ignore
/// fn my_function<D: NetabaseDefinitionTrait>() { ... }
/// ```
///
/// instead of having to repeat all the discriminant bounds.
#[cfg(feature = "paxos")]
pub trait NetabaseDefinitionTrait:
    bincode::Encode
    + bincode::Decode<()>
    + Clone
    + std::fmt::Debug
    + MaybeSend
    + MaybeSync
    + 'static
    + IntoDiscriminant<Discriminant: NetabaseDiscriminant>
    + LogEntry
{
    type Keys: NetabaseDefinitionTraitKey<Discriminant: NetabaseKeyDiscriminant>;
    #[cfg(feature = "redb")]
    type Tables: Clone + Copy;

    /// Get the table definitions for this schema (redb only)
    ///
    /// Returns a struct containing all TableDefinitions for models in this schema.
    /// This method is generated by the `#[netabase_definition_module]` macro.
    #[cfg(feature = "redb")]
    fn tables() -> Self::Tables;

    /// Get the discriminant name as a string (for tree names)
    fn discriminant_name(&self) -> String {
        self.discriminant().to_string()
    }

    fn to_vec(&self) -> Result<Vec<u8>, NetabaseError> {
        bincode::encode_to_vec(&self, bincode::config::standard()).map_err(|e| {
            NetabaseError::Conversion(crate::error::EncodingDecodingError::Encoding(e))
        })
    }
    fn from_vec(vec: &[u8]) -> Result<Self, NetabaseError> {
        Ok(
            bincode::decode_from_slice::<Self, _>(&vec, bincode::config::standard())
                .map_err(|e| {
                    NetabaseError::Conversion(crate::error::EncodingDecodingError::Decoding(e))
                })?
                .0,
        )
    }

    /// Convert this definition to a libp2p kad::Record (native-only)
    #[cfg(all(feature = "libp2p", not(target_arch = "wasm32")))]
    fn to_record(&self) -> Result<libp2p::kad::Record, bincode::error::EncodeError> {
        let key_bytes = bincode::encode_to_vec(self, bincode::config::standard())?;
        let record_key = libp2p::kad::RecordKey::new(&key_bytes);
        let value_bytes = bincode::encode_to_vec(self, bincode::config::standard())?;

        Ok(libp2p::kad::Record {
            key: record_key,
            value: value_bytes,
            publisher: None,
            expires: None,
        })
    }

    /// Apply this definition entry to a store (for Paxos consensus)
    ///
    /// This method is implemented by the netabase_definition_module macro and routes
    /// each Definition variant to the appropriate store operation.
    ///
    /// # Phase 3 Integration
    /// This trait method declaration makes apply_to_store available on the generic
    /// NetabaseDefinitionTrait bound, while the macro provides the actual implementation.
    #[cfg(all(feature = "paxos", feature = "libp2p", not(target_arch = "wasm32")))]
    fn apply_to_store<S>(&self, store: &mut S) -> Result<(), String>
    where
        S: libp2p::kad::store::RecordStore;
}

/// Extension trait for RecordStore helper methods
///
/// This trait provides helper methods that are generated by the macro for each Definition type.
/// The methods handle deserialization, dispatching, and storage of models.
///
/// # Design
///
/// Instead of using a generic `S` parameter (which would cause trait bound issues),
/// we use separate methods for each store backend. This allows each backend to have
/// its own specific OpenTree bounds without violating Rust's trait implementation rules.
/// Note: libp2p requires native networking (mio) and is not available on WASM.
#[cfg(all(feature = "libp2p", not(target_arch = "wasm32")))]
pub trait RecordStoreExt: NetabaseDefinitionTrait
where
    <Self as IntoDiscriminant>::Discriminant: NetabaseDiscriminant,
    <<Self as NetabaseDefinitionTrait>::Keys as IntoDiscriminant>::Discriminant:
        NetabaseKeyDiscriminant,
{
    /// Put this Definition into a Sled store
    #[cfg(feature = "sled")]
    fn handle_sled_put(
        &self,
        store: &crate::databases::sled_store::SledStore<Self>,
    ) -> libp2p::kad::store::Result<()>;

    /// Get a Definition from a Sled store using a RecordKey
    #[cfg(feature = "sled")]
    fn handle_sled_get(
        store: &crate::databases::sled_store::SledStore<Self>,
        key: &libp2p::kad::RecordKey,
    ) -> Option<(Self, libp2p::kad::Record)>;

    /// Remove from a Sled store using a RecordKey
    #[cfg(feature = "sled")]
    fn handle_sled_remove(
        store: &crate::databases::sled_store::SledStore<Self>,
        key: &libp2p::kad::RecordKey,
    );

    /// Get all records from a Sled store as an iterator
    #[cfg(feature = "sled")]
    fn handle_sled_records<'a>(
        store: &'a crate::databases::sled_store::SledStore<Self>,
    ) -> Box<dyn Iterator<Item = std::borrow::Cow<'a, libp2p::kad::Record>> + 'a>;

    /// Put this Definition into a Redb store
    #[cfg(feature = "redb")]
    fn handle_redb_put(
        &self,
        store: &crate::databases::redb_store::RedbStore<Self>,
    ) -> libp2p::kad::store::Result<()>;

    /// Get a Definition from a Redb store using a RecordKey
    #[cfg(feature = "redb")]
    fn handle_redb_get(
        store: &crate::databases::redb_store::RedbStore<Self>,
        key: &libp2p::kad::RecordKey,
    ) -> Option<(Self, libp2p::kad::Record)>;

    /// Remove from a Redb store using a RecordKey
    #[cfg(feature = "redb")]
    fn handle_redb_remove(
        store: &crate::databases::redb_store::RedbStore<Self>,
        key: &libp2p::kad::RecordKey,
    );

    /// Get all records from a Redb store as an iterator
    #[cfg(feature = "redb")]
    fn handle_redb_records<'a>(
        store: &'a crate::databases::redb_store::RedbStore<Self>,
    ) -> Box<dyn Iterator<Item = std::borrow::Cow<'a, libp2p::kad::Record>> + 'a>;

    /// Put this Definition into a Memory store
    #[cfg(feature = "memory")]
    fn handle_memory_put(
        &self,
        store: &crate::databases::memory_store::MemoryStore<Self>,
    ) -> libp2p::kad::store::Result<()>;

    /// Get a Definition from a Memory store using a RecordKey
    #[cfg(feature = "memory")]
    fn handle_memory_get(
        store: &crate::databases::memory_store::MemoryStore<Self>,
        key: &libp2p::kad::RecordKey,
    ) -> Option<(Self, libp2p::kad::Record)>;

    /// Remove from a Memory store using a RecordKey
    #[cfg(feature = "memory")]
    fn handle_memory_remove(
        store: &crate::databases::memory_store::MemoryStore<Self>,
        key: &libp2p::kad::RecordKey,
    );

    /// Put this Definition into an IndexedDB store
    #[cfg(all(feature = "indexeddb", target_arch = "wasm32"))]
    fn handle_indexeddb_put(
        &self,
        store: &crate::databases::indexeddb_store::IndexedDBStore<Self>,
    ) -> libp2p::kad::store::Result<()>;

    /// Get a Definition from an IndexedDB store using a RecordKey
    #[cfg(all(feature = "indexeddb", target_arch = "wasm32"))]
    fn handle_indexeddb_get(
        store: &crate::databases::indexeddb_store::IndexedDBStore<Self>,
        key: &libp2p::kad::RecordKey,
    ) -> Option<(Self, libp2p::kad::Record)>;

    /// Remove from an IndexedDB store using a RecordKey
    #[cfg(all(feature = "indexeddb", target_arch = "wasm32"))]
    fn handle_indexeddb_remove(
        store: &crate::databases::indexeddb_store::IndexedDBStore<Self>,
        key: &libp2p::kad::RecordKey,
    );
}

#[cfg(not(feature = "paxos"))]
pub trait NetabaseDefinitionTrait:
    bincode::Encode
    + bincode::Decode<()>
    + Clone
    + std::fmt::Debug
    + MaybeSend
    + MaybeSync
    + 'static
    + IntoDiscriminant<Discriminant: NetabaseDiscriminant>
{
    type Keys: NetabaseDefinitionTraitKey<Discriminant: NetabaseKeyDiscriminant>;
    #[cfg(feature = "redb")]
    type Tables: Clone + Copy;

    /// Get the table definitions for this schema (redb only)
    ///
    /// Returns a struct containing all TableDefinitions for models in this schema.
    /// This method is generated by the `#[netabase_definition_module]` macro.
    #[cfg(feature = "redb")]
    fn tables() -> Self::Tables;

    /// Get the discriminant name as a string (for tree names)
    fn discriminant_name(&self) -> String {
        self.discriminant().to_string()
    }

    /// Convert this definition to a libp2p kad::Record (native-only)
    #[cfg(all(feature = "libp2p", not(target_arch = "wasm32")))]
    fn to_record(&self) -> Result<libp2p::kad::Record, bincode::error::EncodeError> {
        let key_bytes = bincode::encode_to_vec(self, bincode::config::standard())?;
        let record_key = libp2p::kad::RecordKey::new(&key_bytes);
        let value_bytes = bincode::encode_to_vec(self, bincode::config::standard())?;

        Ok(libp2p::kad::Record {
            key: record_key,
            value: value_bytes,
            publisher: None,
            expires: None,
        })
    }
}

/// Trait for the module-level keys enum that wraps all model keys.
///
/// This trait is automatically implemented by the `#[netabase_definition_module]` macro.
pub trait NetabaseDefinitionTraitKey:
    bincode::Encode
    + bincode::Decode<()>
    + Clone
    + std::fmt::Debug
    + PartialEq
    + Eq
    + std::hash::Hash
    + PartialOrd
    + Ord
    + MaybeSend
    + MaybeSync
    + 'static
    + strum::IntoDiscriminant<Discriminant: NetabaseKeyDiscriminant>
{
    /// Convert this key to a libp2p kad::RecordKey
    #[cfg(all(feature = "libp2p", not(target_arch = "wasm32")))]
    fn to_record_key(&self) -> Result<libp2p::kad::RecordKey, bincode::error::EncodeError> {
        let key_bytes = bincode::encode_to_vec(self, bincode::config::standard())?;
        Ok(libp2p::kad::RecordKey::new(&key_bytes))
    }
}
