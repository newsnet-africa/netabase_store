//! Automatic migration chain generation.
//!
//! This module provides utilities for building and executing migration chains
//! across multiple versions. The macro system uses these to generate optimized
//! migration paths.

use super::{
    MigrateFrom, MigrateTo, MigrationError, MigrationPath, MigrationResult, VersionedModel,
};

/// Builder for creating migration chains at compile time.
///
/// The macro system generates these chains based on the versioned models
/// found in a definition. Each step in the chain is a type that implements
/// `MigrateFrom<PreviousType>`.
pub struct MigrationChainBuilder<Current> {
    _marker: std::marker::PhantomData<Current>,
}

impl<Current: VersionedModel> MigrationChainBuilder<Current> {
    /// Create a new migration chain builder starting from the current version.
    pub const fn new() -> Self {
        Self {
            _marker: std::marker::PhantomData,
        }
    }
}

/// Represents a migration step in the chain.
#[derive(Debug, Clone)]
pub struct MigrationStep {
    /// Source version
    pub from_version: u32,
    /// Target version
    pub to_version: u32,
    /// Whether this step may lose data
    pub may_lose_data: bool,
}

/// A chain of migrations that can be executed.
///
/// This is generated by the macro system and contains all the type information
/// needed to migrate from any known version to the current version.
pub trait MigrationChainExecutor {
    /// The current (target) model type.
    type Current: VersionedModel;

    /// The model family name.
    const FAMILY: &'static str;

    /// All known versions in this family (sorted ascending).
    const VERSIONS: &'static [u32];

    /// Get the migration steps from a source version to current.
    fn steps_from(source_version: u32) -> Option<Vec<MigrationStep>>;

    /// Migrate raw bytes from a source version to current.
    ///
    /// This is the main entry point for database migrations. It:
    /// 1. Deserializes the bytes using the source version's format
    /// 2. Applies each migration step in the chain
    /// 3. Returns the current version
    fn migrate_bytes(source_version: u32, data: &[u8]) -> Result<Self::Current, MigrationError>;
}

/// Trait for types that define the complete version history of a model family.
///
/// Generated by the macro system, this provides all the metadata needed for
/// schema comparison and migration planning.
pub trait VersionHistory {
    /// The model family name.
    const FAMILY: &'static str;

    /// The current version number.
    const CURRENT_VERSION: u32;

    /// All known version numbers (oldest to newest).
    const ALL_VERSIONS: &'static [u32];

    /// Schema hashes for each version (parallel to ALL_VERSIONS).
    const VERSION_HASHES: &'static [u64];

    /// Check if a version is known.
    fn is_known_version(version: u32) -> bool {
        Self::ALL_VERSIONS.contains(&version)
    }

    /// Get the hash for a specific version.
    fn hash_for_version(version: u32) -> Option<u64> {
        Self::ALL_VERSIONS
            .iter()
            .position(|&v| v == version)
            .map(|i| Self::VERSION_HASHES[i])
    }

    /// Check if we can migrate from a given version.
    fn can_migrate_from(version: u32) -> bool {
        Self::is_known_version(version) && version <= Self::CURRENT_VERSION
    }

    /// Check if we can migrate to a given version (downgrade).
    fn can_migrate_to(version: u32) -> bool {
        Self::is_known_version(version) && version < Self::CURRENT_VERSION
    }
}

/// Macro helper for generating migration chain implementations.
///
/// This is used by the proc macro to generate type-safe migration chains.
/// Users don't need to use this directly.
#[doc(hidden)]
pub mod chain_impl {
    use super::*;

    /// Execute a single migration step.
    pub fn execute_step<From, To>(value: From) -> To
    where
        To: MigrateFrom<From>,
    {
        To::migrate_from(value)
    }

    /// Execute a downgrade step.
    pub fn execute_downgrade<From, To>(value: &From) -> To
    where
        From: MigrateTo<To>,
    {
        value.migrate_to()
    }
}

/// Information about a model family's version lineage.
///
/// Used for P2P schema negotiation and conflict resolution.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct FamilyLineage {
    /// The family name.
    pub family: String,
    /// Version history with schema hashes.
    pub versions: Vec<(u32, u64)>,
    /// The current version.
    pub current: u32,
}

impl FamilyLineage {
    /// Find the latest common version between two lineages.
    ///
    /// This is useful for P2P conflict resolution - both nodes can
    /// convert to the common ancestor and then apply their changes.
    pub fn common_ancestor(&self, other: &FamilyLineage) -> Option<u32> {
        if self.family != other.family {
            return None;
        }

        // Find the highest version that exists in both and has matching hash
        for (version, hash) in self.versions.iter().rev() {
            if let Some((_, other_hash)) = other.versions.iter().find(|(v, _)| v == version) {
                if hash == other_hash {
                    return Some(*version);
                }
            }
        }

        None
    }

    /// Check if this lineage is a descendant of another.
    pub fn is_descendant_of(&self, other: &FamilyLineage) -> bool {
        if self.family != other.family {
            return false;
        }

        // Check that all of other's versions exist in self with matching hashes
        other
            .versions
            .iter()
            .all(|(v, h)| self.versions.iter().any(|(sv, sh)| sv == v && sh == h))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_common_ancestor() {
        let lineage1 = FamilyLineage {
            family: "User".to_string(),
            versions: vec![(1, 100), (2, 200), (3, 300)],
            current: 3,
        };

        let lineage2 = FamilyLineage {
            family: "User".to_string(),
            versions: vec![(1, 100), (2, 200), (3, 350)], // V3 diverged
            current: 3,
        };

        assert_eq!(lineage1.common_ancestor(&lineage2), Some(2));
    }

    #[test]
    fn test_is_descendant() {
        let parent = FamilyLineage {
            family: "User".to_string(),
            versions: vec![(1, 100), (2, 200)],
            current: 2,
        };

        let child = FamilyLineage {
            family: "User".to_string(),
            versions: vec![(1, 100), (2, 200), (3, 300)],
            current: 3,
        };

        assert!(child.is_descendant_of(&parent));
        assert!(!parent.is_descendant_of(&child));
    }
}
