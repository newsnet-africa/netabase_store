//! Relational key traits for cross-model references.
//!
//! Relational keys represent foreign key relationships between models,
//! enabling graph-like data structures with proper type safety.
//!
//! # Design
//!
//! Netabase supports:
//! - **Same-definition relationships**: User → User (partner, manager, etc.)
//! - **Cross-definition relationships**: Post → User (author)
//! - **Hydration levels**: Dehydrated, Owned, Hydrated, Borrowed
//!
//! # Examples
//!
//! ```rust,ignore
//! #[derive(NetabaseModel)]
//! pub struct Post {
//!     #[primary]
//!     pub id: PostID,
//!     
//!     #[relational]
//!     pub author: RelationalLink<Standalone, Definition, Definition, User>,
//!     
//!     pub title: String,
//! }
//! ```
//!
//! ## Hydration Levels
//!
//! ```rust,ignore
//! // Just the foreign key
//! let dehydrated = RelationalLink::new_dehydrated(UserID("user1"));
//!
//! // Key with owned data
//! let owned = RelationalLink::new_owned(user_id, user_data);
//!
//! // Key with shared data
//! let hydrated = RelationalLink::new_hydrated(user_id, &user_data);
//!
//! // Key with borrowed data
//! let borrowed = RelationalLink::new_borrowed(user_id, &user_data);
//! ```
//!
//! # Performance Considerations
//!
//! - Dehydrated links have minimal overhead (just the key)
//! - Hydration requires additional queries
//! - Use batch hydration APIs to avoid N+1 query problems
//! - Consider denormalizing frequently-accessed data
//!
//! # Rules and Limitations
//!
//! 1. Relational links must point to valid primary keys
//! 2. Circular references are allowed but require careful handling
//! 3. Deletion semantics are application-defined (no automatic cascades)
//! 4. Cross-definition links require both definitions in scope

use crate::traits::registery::definition::NetabaseDefinition;
use crate::traits::registery::models::StoreKeyMarker;
use crate::traits::registery::models::keys::primary::NetabaseModelPrimaryKey;
use crate::traits::registery::models::model::NetabaseModelMarker;

/// Marker trait for relational keys.
///
/// Relational keys represent foreign key relationships to other models.
/// They enable type-safe cross-model references with optional hydration.
/// 
/// This is a simple marker trait without the K parameter to avoid
/// early/late-bound lifetime issues with GATs.
///
/// # Type Parameters
///
/// - `D`: Source model's definition
/// - `M`: Source model type
///
/// # Automatic Implementation
///
/// Generated by the `#[derive(NetabaseModel)]` macro:
///
/// ```rust,ignore
/// pub enum PostRelationalKeys {
///     Author(UserID),
/// }
///
/// impl NetabaseModelRelationalKey<Definition, Post> for PostRelationalKeys {}
/// ```
pub trait NetabaseModelRelationalKey<
    D: NetabaseDefinition,        // Source definition
    M: NetabaseModelMarker<D>,    // Source model  
>: StoreKeyMarker<D> + Clone
where
    D::Discriminant: 'static + std::fmt::Debug,
{
}

/// Trait for relational keys that reference foreign models.
///
/// This trait extends the marker trait with actual functionality for accessing
/// and constructing foreign key relationships.
/// 
/// # Type Parameters
///
/// - `D`: Source definition (where the relationship originates)
/// - `M`: Source model type
/// - `FD`: Foreign definition (target of the relationship)
/// - `FM`: Foreign model type (what we're pointing to)
///
/// # Methods
///
/// - `foreign_key()`: Extract the foreign primary key
/// - `from_foreign_key()`: Construct a relational link from a foreign key
///
/// # Example
///
/// ```rust,ignore
/// // Get the user ID from a post's author link
/// let author_id: &UserID = post_rel_key.foreign_key();
///
/// // Create a relational key from a user ID  
/// let rel_key = PostRelationalKeys::from_foreign_key(user_id);
/// ```
pub trait NetabaseModelRelationalKeyForeign<
    D: NetabaseDefinition,        // Source definition
    M: NetabaseModelMarker<D>,    // Source model
    FD: NetabaseDefinition,       // Foreign definition  
    FM: NetabaseModelMarker<FD>,  // Foreign model
>: NetabaseModelRelationalKey<D, M>
where
    D::Discriminant: 'static + std::fmt::Debug,
    FD::Discriminant: 'static + std::fmt::Debug,
{
    /// The foreign primary key type this relational key references
    type ForeignPrimaryKey: NetabaseModelPrimaryKey<FD, FM>;
    
    /// Get the foreign primary key value
    fn foreign_key(&self) -> &Self::ForeignPrimaryKey;
    
    /// Create a relational key from a foreign primary key
    fn from_foreign_key(key: Self::ForeignPrimaryKey) -> Self;
}
