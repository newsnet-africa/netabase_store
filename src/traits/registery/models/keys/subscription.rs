//! Subscription key trait for pub/sub patterns.
//!
//! Subscription keys enable models to subscribe to topics, allowing for
//! event-driven architectures and real-time data synchronization.
//!
//! # Design
//!
//! - Models can subscribe to definition-level topics
//! - Topics are defined at the definition level using `subscriptions(...)`
//! - Individual model instances subscribe via `#[subscribe(Topic1, Topic2)]`
//! - Subscription tables map Topic â†’ [Primary Keys] (multimap)
//!
//! # Use Cases
//!
//! - Real-time notifications (notify all users subscribed to "News")
//! - Event broadcasting (publish to all subscribers of a topic)
//! - Data sync (propagate changes to interested parties)
//! - Message queues (topic-based routing)
//!
//! # Examples
//!
//! ## Define Topics
//!
//! ```rust,ignore
//! #[netabase_definition(MyDefinition, subscriptions(News, Updates, Alerts))]
//! pub mod my_definition {
//!     // ... models
//! }
//! ```
//!
//! ## Subscribe Models
//!
//! ```rust,ignore
//! #[derive(NetabaseModel)]
//! #[subscribe(News, Alerts)]  // This model subscribes to News and Alerts
//! pub struct User {
//!     #[primary]
//!     pub id: UserID,
//!     pub name: String,
//! }
//!
//! #[derive(NetabaseModel)]
//! #[subscribe(Updates)]  // This model subscribes to Updates
//! pub struct Post {
//!     #[primary]
//!     pub id: PostID,
//!     pub title: String,
//! }
//! ```
//!
//! ## Query Subscriptions
//!
//! ```rust,ignore
//! // Find all users subscribed to "News"
//! let news_subscribers = txn.list_subscribers::<User>("News")?;
//!
//! // Find what topics a model subscribes to
//! let user_topics = User::get_subscription_keys();
//! ```
//!
//! # Performance
//!
//! - Subscription lookups are O(log n) via multimap indexes
//! - Each topic-model pair creates an index entry
//! - Subscription updates require index maintenance
//!
//! # Rules and Limitations
//!
//! 1. Topics must be declared at definition level
//! 2. Models can only subscribe to topics from their own definition
//! 3. Subscriptions are static (defined at compile time via attributes)
//! 4. Dynamic topic management requires application-level logic
//! 5. No automatic cleanup when subscribers are deleted

use crate::traits::registery::{
    definition::NetabaseDefinition, models::model::NetabaseModelMarker,
};

/// Marker trait for subscription key types.
///
/// Subscription keys connect models to topics, enabling pub/sub patterns.
/// They must be convertible to/from the definition's subscription keys.
///
/// This is a simple marker trait without the K parameter to avoid
/// early/late-bound lifetime issues with GATs.
///
/// # Automatic Implementation
///
/// Generated by the `#[derive(NetabaseModel)]` macro:
///
/// ```rust,ignore
/// // User subscribes to News and Alerts topics
/// impl NetabaseModelSubscriptionKey<MyDefinition, User> for MyDefinitionSubscriptions {}
///
/// // Can convert between model subscriptions and definition subscriptions
/// impl From<MyDefinitionSubscriptions> for UserSubscriptions { ... }
/// impl TryInto<MyDefinitionSubscriptions> for UserSubscriptions { ... }
/// ```
///
/// # See Also
///
/// - [`DefinitionSubscriptionRegistry`](crate::traits::registery::definition::subscription::DefinitionSubscriptionRegistry) - Topic management
pub trait NetabaseModelSubscriptionKey<D: NetabaseDefinition, M: NetabaseModelMarker<D>>:
    From<D::SubscriptionKeys> + TryInto<D::SubscriptionKeys>
where
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: 'static,
{
}
