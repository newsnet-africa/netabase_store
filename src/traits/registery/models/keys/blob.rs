//! Blob key trait for large data storage.
//!
//! Blob keys identify chunks of large data that are stored separately from the main model.
//! This enables efficient storage and retrieval of large binary data without bloating the main table.
//!
//! # Design
//!
//! Large fields (>60KB by default) are automatically:
//! 1. Chunked into 60KB pieces
//! 2. Stored in separate blob tables
//! 3. Indexed by composite keys (primary key + chunk index)
//! 4. Reassembled on read via `NetabaseBlobItem::reconstruct_from_blobs`
//!
//! # Use Cases
//!
//! - Document content (large text)
//! - Images and media files
//! - Serialized data structures
//! - Encryption keys and certificates
//! - Any data >60KB that shouldn't be stored inline
//!
//! # Examples
//!
//! ```rust,ignore
//! use netabase_store::blob::NetabaseBlobItem;
//!
//! #[derive(Clone, Serialize, Deserialize, NetabaseBlobItem)]
//! pub struct LargeUserFile {
//!     pub data: Vec<u8>,      // Automatically chunked if >60KB
//!     pub metadata: String,
//! }
//!
//! #[derive(NetabaseModel)]
//! pub struct User {
//!     #[primary]
//!     pub id: UserID,
//!     
//!     #[blob]
//!     pub avatar: LargeUserFile,  // Stored in blob table
//!     
//!     pub name: String,           // Stored inline
//! }
//! ```
//!
//! # Performance
//!
//! - Blob fields are lazy-loaded (not fetched unless accessed)
//! - Chunking enables parallel reads for very large blobs
//! - Use `CrudOptions::with_blob_strip` to skip blob loading
//! - Blob updates are incremental (only changed chunks rewritten)
//!
//! # Rules and Limitations
//!
//! 1. Blob types must implement `NetabaseBlobItem` trait
//! 2. Chunk size is currently fixed at 60KB (compile-time constant)
//! 3. Maximum blob size is limited by available memory during reassembly
//! 4. Blob data is always serialized with postcard format
//! 5. Partial blob updates not supported (full field replacement only)

use crate::blob::NetabaseBlobItem;
use crate::traits::registery::definition::NetabaseDefinition;
use crate::traits::registery::models::StoreKeyMarker;
pub use crate::traits::registery::models::keys::primary::NetabaseModelPrimaryKey;
use crate::traits::registery::models::model::NetabaseModelMarker;

/// Marker trait for blob key types.
///
/// Blob keys identify chunks of large data stored in separate blob tables.
/// Each blob key associates a primary key with a specific chunk of blob data.
///
/// This is a simple marker trait without the K parameter to avoid
/// early/late-bound lifetime issues with GATs.
///
/// # Associated Types
///
/// - `PrimaryKey`: The model's primary key type
/// - `BlobItem`: The blob data type (must implement `NetabaseBlobItem`)
///
/// # Automatic Implementation
///
/// Generated by the `#[derive(NetabaseModel)]` macro:
///
/// ```rust,ignore
/// pub enum UserBlobKeys {
///     Avatar { primary_key: UserID, chunk: u32 },
/// }
///
/// impl NetabaseModelBlobKey<Definition, User> for UserBlobKeys {
///     type PrimaryKey = UserID;
///     type BlobItem = LargeUserFile;
/// }
/// ```
///
/// # See Also
///
/// - [`NetabaseBlobItem`](crate::blob::NetabaseBlobItem) - Trait for blob data types
/// - [`BLOB_QUERY_METHODS.md`](../../../../../../BLOB_QUERY_METHODS.md) - Blob storage architecture
pub trait NetabaseModelBlobKey<D: NetabaseDefinition, M: NetabaseModelMarker<D>>:
    StoreKeyMarker<D> + Clone
where
    D::Discriminant: 'static + std::fmt::Debug,
{
    type PrimaryKey: NetabaseModelPrimaryKey<D, M>;
    type BlobItem: NetabaseBlobItem;
}
