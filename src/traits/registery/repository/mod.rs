//! Repository trait hierarchy for type-safe inter-definition communication.
//!
//! This module provides compile-time isolation of definitions within repositories,
//! ensuring that relational links can only connect definitions that belong to the
//! same repository context. This is a security feature that prevents unrelated
//! definitions from communicating.
//!
//! # Architecture
//!
//! - **Repository**: A collection of related definitions that can communicate
//! - **InRepository<R>**: Marker trait sealing definitions within repository `R`
//! - **RepositoryDiscriminant**: Strum-based discriminant enum for type-safe matching
//! - **Standalone**: Default repository for definitions not in explicit repositories
//!
//! # Security Model
//!
//! Repositories act as the top-level schema boundary. Nothing can access
//! definitions outside of its repository context. This creates isolated
//! contexts where `Employee` in `EmployeeRepo` is completely separate from
//! `Employee` in `ManagerRepo`, even if they share the same underlying definition.
//!
//! ## Compile-Time Guarantees
//!
//! - RelationalLinks cannot cross repository boundaries
//! - Type system enforces complete data graph requirements
//! - Missing dependencies cause compilation errors, not runtime failures
//!
//! ## Use Cases
//!
//! - **Multi-Tenancy**: Each tenant gets isolated repository
//! - **Microservices**: Service-specific data graphs
//! - **Security Boundaries**: Separate sensitive from public data
//!
//! # Standalone Mode
//!
//! Definitions that don't specify `repos(...)` are automatically placed in the
//! `Standalone` repository. This provides backward compatibility while still
//! allowing explicit repository isolation when needed. All standalone definitions
//! can communicate with each other.
//!
//! # Limitations
//!
//! - Repositories cannot be changed at runtime
//! - Cross-repository queries require manual coordination
//! - Repository structure is fixed at compile time
//!
//! # Example
//!
//! ```rust
//! use serde::{Serialize, Deserialize};
//!
//! // Define models in a repository
//! #[derive(netabase_macros::NetabaseModel, Debug, Clone, Serialize, Deserialize, PartialEq)]
//! struct Employee {
//!     #[primary_key]
//!     id: String,
//!     name: String,
//! }
//!
//! #[netabase_macros::netabase_definition(EmployeeDef)]
//! mod employee_def { use super::*; }
//!
//! // Employee definitions can now have relational links within the context
//! ```

use std::hash::Hash;

use crate::traits::registery::definition::NetabaseDefinition;

/// Trait for types that can be used as repository discriminants.
///
/// Repository discriminants are strongly typed enum variants that identify
/// which definitions belong to a repository. They are generated by the
/// `#[netabase_repository]` macro using strum derives.
pub trait RepositoryDiscriminant:
    Clone + Copy + PartialEq + Eq + Hash + std::fmt::Debug + 'static
{
}

/// Blanket implementation for any type meeting the requirements.
impl<T> RepositoryDiscriminant for T where
    T: Clone + Copy + PartialEq + Eq + Hash + std::fmt::Debug + 'static
{
}

/// Trait for model discriminants flattened across all definitions in a repository.
///
/// This allows type-safe access to any model within the repository context
/// using a single enum type.
pub trait RepositoryModelDiscriminant:
    Clone + Copy + PartialEq + Eq + Hash + std::fmt::Debug + 'static
{
}

/// Blanket implementation for any type meeting the requirements.
impl<T> RepositoryModelDiscriminant for T where
    T: Clone + Copy + PartialEq + Eq + Hash + std::fmt::Debug + 'static
{
}

/// Core repository trait that groups related definitions for inter-definition communication.
///
/// This trait is implemented by repository marker structs generated via the
/// `#[netabase_repository(RepoName)]` macro. It provides type-safe access to
/// all definitions within the repository.
///
/// # Associated Types
///
/// - `RepositoryDefinition`: Enum wrapping all definitions in the repository
/// - `RepositoryDiscriminant`: Strum-based discriminant for the definition enum
/// - `RepositoryModelKeys`: Flattened discriminant enum for all models across definitions
///
/// # Security
///
/// Repositories enforce complete data graph requirements at compile time.
/// If a definition has relational links to another definition, both must
/// be included in the same repository.
pub trait NetabaseRepository: Sized + 'static {
    /// Enum type holding all definition instances in this repository.
    ///
    /// Generated as:
    /// ```rust
    /// # // Example of generated enum structure
    /// # #[derive(Clone, Debug)]
    /// # pub enum RepoNameDefinition {
    /// #     Employee,
    /// #     Inventory,
    /// # }
    /// ```
    type RepositoryDefinition: Clone + std::fmt::Debug;

    /// Discriminant enum for definitions in this repository.
    ///
    /// Generated with strum derives for efficient matching:
    /// ```rust
    /// # // Example of generated discriminant enum
    /// # #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
    /// # pub enum RepoNameDefinitionDiscriminant {
    /// #     Employee,
    /// #     Inventory,
    /// # }
    /// ```
    type RepositoryDiscriminant: RepositoryDiscriminant;

    /// Flattened model discriminant enum across all definitions.
    ///
    /// Allows type-safe identification of any model in the repository:
    /// ```rust
    /// # // Example of generated model discriminant enum
    /// # #[derive(Clone, Copy, Debug)]
    /// # pub enum RepoNameModelDiscriminant {
    /// #     EmployeeUser,
    /// #     EmployeeShift,
    /// #     InventoryItem,
    /// # }
    /// ```
    type RepositoryModelKeys: RepositoryModelDiscriminant;

    /// Returns the name of this repository as a static string.
    fn name() -> &'static str;

    /// Returns the number of definitions in this repository.
    fn definition_count() -> usize;

    /// Returns the number of models across all definitions in this repository.
    fn model_count() -> usize;
}

/// Marker trait that seals a definition within a specific repository context.
///
/// This trait is the core of the repository isolation security model.
/// A definition can implement `InRepository<R>` for multiple repositories,
/// allowing it to participate in different repository contexts.
///
/// # Compile-Time Safety
///
/// The `RelationalLink` type uses this trait bound to ensure that both
/// source and target definitions belong to the same repository:
///
/// ```rust
/// // Conceptual structure - enforced at compile time
/// # trait NetabaseRepository {}
/// # trait InRepository<R> {}
/// // pub struct RelationalLink<'a, R, SourceD, TargetD>
/// // where
/// //     R: NetabaseRepository,
/// //     SourceD: InRepository<R>,
/// //     TargetD: InRepository<R>,
/// // { }
/// ```
///
/// This prevents linking definitions from different repositories at compile time.
pub trait InRepository<R: NetabaseRepository>: NetabaseDefinition
where
    Self::Discriminant: 'static + std::fmt::Debug,
{
    /// The discriminant type for this definition within the repository.
    type RepositoryDiscriminant: RepositoryDiscriminant;

    /// Returns this definition's discriminant within the repository.
    fn repository_discriminant() -> Self::RepositoryDiscriminant;
}

/// Metadata about schema migrations for version compatibility.
///
/// This struct captures information needed for future migration support,
/// including field renames, type changes, and structural modifications.
///
/// # Use Cases
///
/// - **P2P Schema Negotiation**: Nodes can compare migration metadata to
///   determine compatibility and automatic upgrade paths
/// - **Breaking Change Detection**: Identifies schema changes that cannot
///   be automatically migrated
/// - **Migration Planning**: Provides hints for constructing migration logic
///
/// # Example
///
/// ```
/// use netabase_store::traits::registery::repository::{MigrationMetadata, FieldRename};
///
/// let mut metadata = MigrationMetadata::default();
/// metadata.field_renames.push(FieldRename {
///     definition: "UserDef",
///     model: "User",
///     old_name: "username",
///     new_name: "email",
/// });
///
/// // Check if there are any field renames
/// assert!(!metadata.field_renames.is_empty());
/// ```
#[derive(Debug, Clone, Default)]
pub struct MigrationMetadata {
    /// Fields that have been renamed (old_name -> new_name).
    pub field_renames: Vec<FieldRename>,

    /// Fields whose types have changed.
    pub type_changes: Vec<TypeChange>,

    /// Fields that have been added.
    pub added_fields: Vec<FieldInfo>,

    /// Fields that have been removed.
    pub removed_fields: Vec<FieldInfo>,
}

/// Information about a field rename.
#[derive(Debug, Clone)]
pub struct FieldRename {
    /// Definition containing the field.
    pub definition: &'static str,
    /// Model containing the field.
    pub model: &'static str,
    /// Original field name.
    pub old_name: &'static str,
    /// New field name.
    pub new_name: &'static str,
}

/// Information about a field type change.
#[derive(Debug, Clone)]
pub struct TypeChange {
    /// Definition containing the field.
    pub definition: &'static str,
    /// Model containing the field.
    pub model: &'static str,
    /// Field name.
    pub field_name: &'static str,
    /// Original type (as string).
    pub old_type: &'static str,
    /// New type (as string).
    pub new_type: &'static str,
}

/// Basic field information for tracking additions/removals.
#[derive(Debug, Clone)]
pub struct FieldInfo {
    /// Definition containing the field.
    pub definition: &'static str,
    /// Model containing the field.
    pub model: &'static str,
    /// Field name.
    pub field_name: &'static str,
    /// Field type (as string).
    pub field_type: &'static str,
}

/// Repository-scoped permissions for access validation.
///
/// This struct provides fine-grained access control at the repository level,
/// allowing you to restrict which models can be accessed and what operations
/// are permitted.
///
/// # Security Model
///
/// Permissions operate within a repository context. A permission set specifies:
/// - Which models can be accessed (by discriminant)
/// - Whether read operations are allowed
/// - Whether write operations are allowed
/// - Whether hydration (loading related data) is allowed
///
/// # Use Cases
///
/// - **Read-Only Transactions**: Create views that can query but not modify
/// - **Restricted Access**: Limit access to specific models only
/// - **Audit Operations**: Prevent hydration during read-only audits
///
/// # Example
///
/// ```rust
/// // Permissions are used internally by the database layer
/// // to control access to specific models and operations
/// ```
#[derive(Debug, Clone)]
pub struct RepositoryPermissions<R: NetabaseRepository> {
    /// List of accessible model discriminants within the repository.
    pub accessible_models: Vec<R::RepositoryModelKeys>,
    /// Whether read access is allowed.
    pub read_allowed: bool,
    /// Whether write access is allowed.
    pub write_allowed: bool,
    /// Whether hydration (loading related data) is allowed.
    pub hydration_allowed: bool,
}

impl<R: NetabaseRepository> RepositoryPermissions<R> {
    /// Create new repository permissions.
    pub fn new(
        accessible_models: Vec<R::RepositoryModelKeys>,
        read_allowed: bool,
        write_allowed: bool,
        hydration_allowed: bool,
    ) -> Self {
        Self {
            accessible_models,
            read_allowed,
            write_allowed,
            hydration_allowed,
        }
    }

    /// Create read-only permissions with specified models.
    pub fn read_only(accessible_models: Vec<R::RepositoryModelKeys>) -> Self {
        Self::new(accessible_models, true, false, true)
    }

    /// Create full permissions with specified models.
    pub fn full_access(accessible_models: Vec<R::RepositoryModelKeys>) -> Self {
        Self::new(accessible_models, true, true, true)
    }

    /// Create no permissions.
    pub fn no_access() -> Self {
        Self::new(Vec::new(), false, false, false)
    }

    /// Check if read operations are allowed.
    #[inline]
    pub fn can_read(&self) -> bool {
        self.read_allowed
    }

    /// Check if write operations are allowed.
    #[inline]
    pub fn can_write(&self) -> bool {
        self.write_allowed
    }

    /// Check if hydration operations are allowed.
    #[inline]
    pub fn can_hydrate(&self) -> bool {
        self.hydration_allowed
    }

    /// Check if a specific model is accessible.
    #[inline]
    pub fn can_access_model(&self, key: &R::RepositoryModelKeys) -> bool {
        self.accessible_models.contains(key)
    }
}

/// Represents a repository schema for P2P comparison.
///
/// This struct encapsulates all the information needed to compare
/// repository schemas between nodes in a peer-to-peer network.
///
/// # Schema Comparison Strategy
///
/// 1. **Quick Check**: Compare `schema_hash` first for fast identity check
/// 2. **Granular Check**: If hashes differ, compare `definition_hashes`
///    to identify which specific definitions changed
/// 3. **Migration Hints**: Use `migration_hints` to determine if automatic
///    migration is possible
///
/// # Use Cases
///
/// - **P2P Handshake**: Exchange schemas during node connection
/// - **Conflict Detection**: Identify incompatible schema versions
/// - **Upgrade Coordination**: Determine if nodes can communicate despite
///   schema differences
///
/// # Example
///
/// ```rust
/// // Repository schemas are used internally for P2P synchronization
/// // and schema comparison between database instances
/// ```
#[derive(Debug, Clone)]
pub struct RepositorySchema {
    /// Name of the repository.
    pub repository_name: String,
    /// Full schema as TOML string.
    pub schema_toml: String,
    /// Hash of the schema for quick comparison.
    pub schema_hash: u64,
    /// Per-definition schema hashes for granular comparison.
    pub definition_hashes: std::collections::HashMap<String, u64>,
    /// Migration metadata for version compatibility.
    pub migration_hints: MigrationMetadata,
}

/// Result of comparing two repository schemas.
///
/// Provides detailed information about differences between local and remote
/// schemas, enabling informed decisions about compatibility and migration.
///
/// # Compatibility Rules
///
/// - Schemas are **compatible** if all definitions exist in both and have
///   matching hashes
/// - Additional definitions in one side indicate **schema extensions**
/// - Modified definitions indicate **schema evolution** requiring migration
///
/// # Example
///
/// ```
/// use netabase_store::traits::registery::repository::SchemaDiff;
///
/// let diff = SchemaDiff {
///     compatible: false,
///     local_only: vec!["NewUserModel".to_string()],
///     remote_only: vec![],
///     modified: vec!["Post".to_string()],
///     details: vec!["Post.content changed from String to Text".to_string()],
/// };
///
/// if !diff.compatible {
///     println!("Schema mismatch detected:");
///     for def in &diff.modified {
///         println!("  - Modified: {}", def);
///     }
/// }
///
/// assert!(!diff.is_identical());
/// ```
#[derive(Debug, Clone)]
pub struct SchemaDiff {
    /// Whether the schemas are compatible.
    pub compatible: bool,
    /// Definitions that exist in local but not remote.
    pub local_only: Vec<String>,
    /// Definitions that exist in remote but not local.
    pub remote_only: Vec<String>,
    /// Definitions with different schemas.
    pub modified: Vec<String>,
    /// Detailed differences for modified definitions.
    pub details: Vec<String>,
}

impl SchemaDiff {
    /// Check if schemas are identical.
    pub fn is_identical(&self) -> bool {
        self.local_only.is_empty() && self.remote_only.is_empty() && self.modified.is_empty()
    }
}

/// Compare two repository schemas.
pub fn compare_schemas(local: &RepositorySchema, remote: &RepositorySchema) -> SchemaDiff {
    let mut diff = SchemaDiff {
        compatible: true,
        local_only: Vec::new(),
        remote_only: Vec::new(),
        modified: Vec::new(),
        details: Vec::new(),
    };

    // Quick hash comparison
    if local.schema_hash == remote.schema_hash {
        return diff;
    }

    // Compare definition hashes
    for (name, hash) in &local.definition_hashes {
        match remote.definition_hashes.get(name) {
            Some(remote_hash) if remote_hash == hash => {}
            Some(_) => {
                diff.modified.push(name.clone());
            }
            None => {
                diff.local_only.push(name.clone());
            }
        }
    }

    for name in remote.definition_hashes.keys() {
        if !local.definition_hashes.contains_key(name) {
            diff.remote_only.push(name.clone());
        }
    }

    // Schemas are incompatible if there are differences
    diff.compatible = diff.local_only.is_empty() && diff.remote_only.is_empty();

    diff
}

// ============================================================================
// Standalone Repository
// ============================================================================

/// Discriminant for standalone definitions.
///
/// This is a unit type since standalone definitions don't have a predefined
/// enumeration - any definition without `repos(...)` belongs here.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct StandaloneDiscriminant;

/// Placeholder enum for standalone definition wrapper.
///
/// In practice, standalone definitions don't need a unified wrapper enum
/// since they're accessed individually. This type satisfies the trait bounds.
#[derive(Debug, Clone)]
pub enum StandaloneDefinition {
    /// Placeholder variant - standalone definitions are accessed directly.
    _Placeholder,
}

/// Placeholder for standalone model keys.
///
/// Similar to `StandaloneDefinition`, this satisfies trait bounds without
/// providing actual functionality since standalone definitions are
/// accessed individually.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct StandaloneModelKeys;

/// The default repository for definitions not explicitly assigned to a repository.
///
/// When a definition is declared without `repos(...)`, it automatically
/// belongs to the `Standalone` repository. This allows definitions to use
/// `RelationalLink` without requiring explicit repository membership.
///
/// # Behavior
///
/// - All standalone definitions can communicate with each other
/// - No compile-time isolation between standalone definitions
/// - Definitions can opt into isolation by specifying `repos(...)`
///
/// # Example
///
/// ```rust
/// // Definitions without explicit repository specification
/// // automatically belong to the Standalone repository:
/// use serde::{Serialize, Deserialize};
///
/// #[derive(netabase_macros::NetabaseModel, Debug, Clone, Serialize, Deserialize, PartialEq)]
/// struct Config {
///     #[primary_key]
///     id: String,
///     value: String,
/// }
///
/// #[netabase_macros::netabase_definition(ConfigDef)]
/// mod config { use super::*; }
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct Standalone;

impl NetabaseRepository for Standalone {
    type RepositoryDefinition = StandaloneDefinition;
    type RepositoryDiscriminant = StandaloneDiscriminant;
    type RepositoryModelKeys = StandaloneModelKeys;

    #[inline]
    fn name() -> &'static str {
        "Standalone"
    }

    #[inline]
    fn definition_count() -> usize {
        // Dynamic - not tracked at compile time for standalone
        0
    }

    #[inline]
    fn model_count() -> usize {
        // Dynamic - not tracked at compile time for standalone
        0
    }
}
