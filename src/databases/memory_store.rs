use crate::error::NetabaseError;
use crate::traits::convert::ToIVec;
use crate::traits::definition::{NetabaseDefinitionTrait, NetabaseDefinitionWithSubscription};
use crate::traits::model::NetabaseModelTrait;
use crate::traits::tree::NetabaseTreeSync;
use crate::{MaybeSend, MaybeSync};
use std::collections::HashMap;
use std::marker::PhantomData;
use std::str::FromStr;
use std::sync::{Arc, RwLock};
use strum::{IntoDiscriminant, IntoEnumIterator};

/// Type-safe in-memory key-value store.
///
/// `MemoryStore` provides a high-performance, type-safe in-memory storage backend,
/// using model discriminants as tree names and ensuring all operations are compile-time checked.
///
/// This backend is ideal for:
/// - Testing and development
/// - Temporary data storage
/// - High-performance scenarios where persistence is not required
/// - Caching layers
///
/// # Type Parameters
///
/// * `D` - A type implementing `NetabaseDefinitionTrait`, typically generated by the
///   `#[netabase_definition_module]` macro
///
/// # Examples
///
/// ## Basic Usage
///
/// ```rust
/// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// use netabase_store::databases::memory_store::MemoryStore;
/// use netabase_store::traits::tree::NetabaseTreeSync;
/// use netabase_store::traits::model::NetabaseModelTrait;
///
/// // Define your schema
/// #[netabase_definition_module(BlogDefinition, BlogKeys)]
/// mod blog {
///     use super::*;
///     use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
///              bincode::Encode, bincode::Decode,
///              serde::Serialize, serde::Deserialize)]
///     #[netabase(BlogDefinition)]
///     pub struct User {
///         #[primary_key]
///         pub id: u64,
///         pub name: String,
///         #[secondary_key]
///         pub email: String,
///     }
/// }
///
/// use blog::*;
///
/// // Create an in-memory database
/// let store = MemoryStore::<BlogDefinition>::new();
///
/// // Open a type-safe tree for the User model
/// let user_tree = store.open_tree::<User>();
///
/// // Insert a user
/// let alice = User {
///     id: 1,
///     name: "Alice".to_string(),
///     email: "alice@example.com".to_string(),
/// };
/// user_tree.put(alice.clone()).unwrap();
///
/// // Retrieve by primary key
/// let retrieved = user_tree.get(alice.primary_key()).unwrap();
/// assert_eq!(retrieved, Some(alice));
/// ```
pub struct MemoryStore<D>
where
    D: NetabaseDefinitionTrait,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Shared data storage across all trees
    data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
    pub trees: Vec<D::Discriminant>,
}

impl<D> MemoryStore<D>
where
    D: NetabaseDefinitionTrait + ToIVec,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Create a new in-memory `MemoryStore`.
    ///
    /// Creates an empty in-memory database. All data is lost when the store is dropped.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::memory_store::MemoryStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app { use super::*;
    /// #   use netabase_store::{NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode, serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(AppDef)]
    /// #   pub struct User { #[primary_key] pub id: u64, pub name: String }
    /// # }
    /// # use app::*;
    /// // Create an in-memory database
    /// let store = MemoryStore::<AppDef>::new();
    ///
    /// // Use it like any other store
    /// let user_tree = store.open_tree::<User>();
    /// ```
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            trees: D::Discriminant::iter().collect(),
        }
    }

    /// Open a type-safe tree for a specific model type.
    ///
    /// Returns a `MemoryStoreTree` that provides CRUD operations for a single model type.
    /// Each model type gets its own tree within the database, identified by its discriminant.
    ///
    /// # Type Parameters
    ///
    /// * `M` - The model type, must implement `NetabaseModelTrait<D>`
    ///
    /// # Returns
    ///
    /// A `MemoryStoreTree<D, M>` ready for CRUD operations on the specified model type.
    /// The returned tree is tied to the lifetime of this store, ensuring it cannot outlive the database.
    pub fn open_tree<M>(&self) -> MemoryStoreTree<'_, D, M>
    where
        M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
        D: TryFrom<M> + ToIVec,
    {
        MemoryStoreTree::new(Arc::clone(&self.data), M::DISCRIMINANT)
    }

    /// Get all model discriminants (tree names) in the database schema.
    ///
    /// Returns a vector of all discriminants defined in the definition enum.
    pub fn tree_names(&self) -> Vec<D::Discriminant> {
        D::Discriminant::iter().collect()
    }

    /// Clear all data from the store.
    pub fn clear(&self) -> Result<(), NetabaseError> {
        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;
        data.clear();
        Ok(())
    }

    /// Open a subscription tree for a specific subscription type
    ///
    /// Returns a `MemorySubscriptionTree` that provides subscription operations.
    /// Each subscription type gets its own table within the database.
    pub fn open_subscription_tree<S>(
        &self,
        subscription: S,
    ) -> MemorySubscriptionTree<'_, D, S>
    where
        D: NetabaseDefinitionWithSubscription<Subscriptions = S>,
        S: strum::IntoDiscriminant,
        <S as strum::IntoDiscriminant>::Discriminant: AsRef<str>,
    {
        MemorySubscriptionTree::new(Arc::clone(&self.data), subscription)
    }
}

impl<D> Default for MemoryStore<D>
where
    D: NetabaseDefinitionTrait + ToIVec,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn default() -> Self {
        Self::new()
    }
}

/// Type-safe wrapper around an in-memory tree for a specific model type.
///
/// `MemoryStoreTree` provides CRUD operations for a single model type with:
/// - Automatic bincode serialization/deserialization
/// - Primary key indexing
/// - Secondary key indexing and querying
/// - Type-safe operations (compile-time checking)
///
/// # Type Parameters
///
/// * `D` - The definition type (generated by `#[netabase_definition_module]`)
/// * `M` - The model type (annotated with `#[derive(NetabaseModel)]`)
pub struct MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
    tree_name: String,
    secondary_tree_name: String,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
    _phantom_db: PhantomData<&'db ()>,
}

impl<'db, D, M> MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Create a new MemoryStoreTree
    fn new(
        data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
        tree_name: D::Discriminant,
    ) -> Self {
        let tree_name_str = tree_name.to_string();
        let secondary_tree_name = format!("{}_secondary", M::discriminant_name());

        Self {
            data,
            tree_name: tree_name_str,
            secondary_tree_name,
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
            _phantom_db: PhantomData,
        }
    }

    /// Insert or update a model in the tree.
    pub fn put(&self, model: M) -> Result<(), NetabaseError>
    where
        D: From<M>,
    {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let definition: D = model.into();
        #[cfg(feature = "native")]
        let value_bytes = definition.to_ivec()?;
        #[cfg(all(feature = "wasm", not(feature = "native")))]
        let value_bytes = definition.to_vec()?;
        #[cfg(not(any(feature = "native", feature = "wasm")))]
        let value_bytes = bincode::encode_to_vec(&definition, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Insert into primary tree
        {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let tree = data
                .entry(self.tree_name.clone())
                .or_insert_with(HashMap::new);
            tree.insert(key_bytes.clone(), value_bytes.to_vec());
        }

        // Insert secondary key indexes
        if !secondary_keys.is_empty() {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let sec_tree = data
                .entry(self.secondary_tree_name.clone())
                .or_insert_with(HashMap::new);

            for sec_key in secondary_keys.values() {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_tree.insert(composite_key, vec![]);
            }
        }

        Ok(())
    }

    /// Get a model by its primary key.
    pub fn get(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(tree) = data.get(&self.tree_name) {
            if let Some(value_bytes) = tree.get(&key_bytes) {
                #[cfg(feature = "native")]
                let definition = D::from_ivec(&value_bytes.as_slice().into())?;
                #[cfg(all(feature = "wasm", not(feature = "native")))]
                let definition = D::from_vec(value_bytes.as_slice())?;
                #[cfg(not(any(feature = "native", feature = "wasm")))]
                let definition: D = {
                    let (def, _) = bincode::decode_from_slice(value_bytes.as_slice(), bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;
                    def
                };
                match M::try_from(definition) {
                    Ok(model) => return Ok(Some(model)),
                    Err(_) => return Ok(None),
                }
            }
        }

        Ok(None)
    }

    /// Delete a model by its primary key.
    pub fn remove(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // First get the model to return it and clean up secondary keys
        let model = self.get(key.clone())?;

        if let Some(ref m) = model {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            // Remove from primary tree
            if let Some(tree) = data.get_mut(&self.tree_name) {
                tree.remove(&key_bytes);
            }

            // Remove secondary keys
            let secondary_keys = m.secondary_keys();
            if !secondary_keys.is_empty() {
                if let Some(sec_tree) = data.get_mut(&self.secondary_tree_name) {
                    for sec_key in secondary_keys.values() {
                        let composite_key = self.build_composite_key(sec_key, &key)?;
                        sec_tree.remove(&composite_key);
                    }
                }
            }
        }

        Ok(model)
    }

    /// Iterate over all models in the tree.
    pub fn iter(&self) -> MemoryIter<D, M> {
        let data = self.data.read().ok();
        let entries = data
            .and_then(|d| d.get(&self.tree_name).map(|t| t.clone()))
            .unwrap_or_default();

        MemoryIter {
            entries: entries.into_iter().collect(),
            current: 0,
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
        }
    }

    /// Get the total number of models in the tree.
    pub fn len(&self) -> usize {
        let data = self.data.read().ok();
        data.and_then(|d| d.get(&self.tree_name).map(|t| t.len()))
            .unwrap_or(0)
    }

    /// Check if the tree contains no models.
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// Clear all models from the tree.
    pub fn clear(&self) -> Result<(), NetabaseError> {
        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        if let Some(tree) = data.get_mut(&self.tree_name) {
            tree.clear();
        }
        if let Some(sec_tree) = data.get_mut(&self.secondary_tree_name) {
            sec_tree.clear();
        }

        Ok(())
    }

    /// Build a composite key from secondary key + primary key
    fn build_composite_key(
        &self,
        secondary_key: &<M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey,
        primary_key: &<M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Vec<u8>, NetabaseError> {
        let mut composite_key = bincode::encode_to_vec(secondary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;
        let prim_key_bytes = bincode::encode_to_vec(primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        composite_key.extend_from_slice(&prim_key_bytes);
        Ok(composite_key)
    }

    /// Find all models matching a secondary key value.
    pub fn get_by_secondary_key(
        &self,
        secondary_key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey,
    ) -> Result<Vec<M>, NetabaseError>
    where
        <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
            bincode::Decode<()>,
    {
        let sec_key_bytes = bincode::encode_to_vec(&secondary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // First, collect all primary keys
        let primary_keys = {
            let data = self
                .data
                .read()
                .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

            let mut keys = Vec::new();

            if let Some(sec_tree) = data.get(&self.secondary_tree_name) {
                for (composite_key, _) in sec_tree.iter() {
                    if composite_key.starts_with(&sec_key_bytes) {
                        let prim_key_start = sec_key_bytes.len();
                        if composite_key.len() > prim_key_start {
                            let (primary_key, _) = bincode::decode_from_slice::<<M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey, _>(
                                &composite_key[prim_key_start..],
                                bincode::config::standard(),
                            )
                            .map_err(crate::error::EncodingDecodingError::from)?;
                            keys.push(primary_key);
                        }
                    }
                }
            }

            keys
        }; // Lock is released here

        // Now get all models for the collected primary keys
        let mut results = Vec::new();
        for primary_key in primary_keys {
            if let Some(model) = self.get(primary_key)? {
                results.push(model);
            }
        }

        Ok(results)
    }
}

/// Iterator over models in a MemoryStoreTree
pub struct MemoryIter<D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    entries: Vec<(Vec<u8>, Vec<u8>)>,
    current: usize,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
}

impl<D, M> Iterator for MemoryIter<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec,
    M: NetabaseModelTrait<D> + TryFrom<D>,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type Item = Result<
        (
            <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
            M,
        ),
        NetabaseError,
    >;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current >= self.entries.len() {
            return None;
        }

        let (key_bytes, value_bytes) = &self.entries[self.current];
        self.current += 1;

        let result = (|| {
            let (key, _) = bincode::decode_from_slice::<
                <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
                _,
            >(key_bytes, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

            #[cfg(feature = "native")]
            let definition = D::from_ivec(&value_bytes.as_slice().into())?;
            #[cfg(all(feature = "wasm", not(feature = "native")))]
            let definition = D::from_vec(value_bytes.as_slice())?;
            #[cfg(not(any(feature = "native", feature = "wasm")))]
            let definition: D = {
                let (def, _) = bincode::decode_from_slice(value_bytes.as_slice(), bincode::config::standard())
                    .map_err(crate::error::EncodingDecodingError::from)?;
                def
            };
            let model = M::try_from(definition).map_err(|_| {
                crate::error::NetabaseError::Conversion(
                    crate::error::EncodingDecodingError::Decoding(
                        bincode::error::DecodeError::Other("Type conversion failed"),
                    ),
                )
            })?;

            Ok((key, model))
        })();

        Some(result)
    }
}

// Implement the unified NetabaseTreeSync trait for MemoryStoreTree
impl<'db, D, M> NetabaseTreeSync<'db, D, M> for MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type PrimaryKey = <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey;
    type SecondaryKeys = <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey;

    fn put(&self, model: M) -> Result<(), NetabaseError> {
        self.put(model)
    }

    fn get(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.get(key)
    }

    fn remove(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.remove(key)
    }

    fn get_by_secondary_key(
        &self,
        secondary_key: Self::SecondaryKeys,
    ) -> Result<Vec<M>, NetabaseError> {
        self.get_by_secondary_key(secondary_key)
    }

    fn is_empty(&self) -> Result<bool, NetabaseError> {
        Ok(self.is_empty())
    }

    fn len(&self) -> Result<usize, NetabaseError> {
        Ok(self.len())
    }

    fn clear(&self) -> Result<(), NetabaseError> {
        self.clear()
    }
}

// Implement StoreOps trait for MemoryStoreTree
impl<'db, D, M> crate::traits::store_ops::StoreOps<D, M> for MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone + bincode::Decode<()>,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn put_raw(&self, model: M) -> Result<(), NetabaseError> {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let value_bytes = bincode::encode_to_vec(&model, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let tree = data
                .entry(self.tree_name.clone())
                .or_insert_with(HashMap::new);
            tree.insert(key_bytes, value_bytes);
        }

        if !secondary_keys.is_empty() {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let sec_tree = data
                .entry(self.secondary_tree_name.clone())
                .or_insert_with(HashMap::new);

            for sec_key in secondary_keys.values() {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_tree.insert(composite_key, vec![]);
            }
        }

        Ok(())
    }

    fn get_raw(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(tree) = data.get(&self.tree_name) {
            if let Some(value_bytes) = tree.get(&key_bytes) {
                let (model, _) =
                    bincode::decode_from_slice::<M, _>(value_bytes, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;
                return Ok(Some(model));
            }
        }

        Ok(None)
    }

    fn remove_raw(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let model = self.get_raw(key.clone())?;

        if let Some(ref m) = model {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            if let Some(tree) = data.get_mut(&self.tree_name) {
                tree.remove(&key_bytes);
            }

            let secondary_keys = m.secondary_keys();
            if !secondary_keys.is_empty() {
                if let Some(sec_tree) = data.get_mut(&self.secondary_tree_name) {
                    for sec_key in secondary_keys.values() {
                        let composite_key = self.build_composite_key(sec_key, &key)?;
                        sec_tree.remove(&composite_key);
                    }
                }
            }
        }

        Ok(model)
    }

    fn discriminant(&self) -> &str {
        M::discriminant_name()
    }
}

// Implement StoreOpsSecondary trait for MemoryStoreTree
impl<'db, D, M> crate::traits::store_ops::StoreOpsSecondary<D, M> for MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone + bincode::Decode<()>,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn get_by_secondary_key_raw(
        &self,
        secondary_key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey,
    ) -> Result<Vec<M>, NetabaseError> {
        self.get_by_secondary_key(secondary_key)
    }
}

// Implement OpenTree trait for MemoryStore
impl<D, M> crate::traits::store_ops::OpenTree<D, M> for MemoryStore<D>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + crate::traits::convert::ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone + bincode::Decode<()>,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as strum::IntoDiscriminant>::Discriminant: crate::traits::definition::NetabaseDiscriminant,
{
    type Tree<'a>
        = MemoryStoreTree<'a, D, M>
    where
        Self: 'a;

    fn open_tree(&self) -> Self::Tree<'_> {
        MemoryStoreTree::new(Arc::clone(&self.data), M::DISCRIMINANT)
    }
}

/// In-memory subscription tree for managing subscription data
///
/// This provides methods to manage subscriptions within the memory store.
/// Each subscription variant has its own table, similar to regular model tables.
pub struct MemorySubscriptionTree<'db, D, S>
where
    D: NetabaseDefinitionTrait + NetabaseDefinitionWithSubscription<Subscriptions = S>,
    S: strum::IntoDiscriminant,
{
    data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
    table_name: String,
    _phantom_d: PhantomData<D>,
    _phantom_s: PhantomData<S>,
    _phantom_db: PhantomData<&'db ()>,
}

impl<'db, D, S> MemorySubscriptionTree<'db, D, S>
where
    D: NetabaseDefinitionTrait + NetabaseDefinitionWithSubscription<Subscriptions = S>,
    S: strum::IntoDiscriminant,
    <S as strum::IntoDiscriminant>::Discriminant: AsRef<str>,
{
    /// Create a new MemorySubscriptionTree
    fn new(
        data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
        subscription: S,
    ) -> Self {
        let discriminant = subscription.discriminant();
        let table_name = format!("subscription_{}", discriminant.as_ref());

        Self {
            data,
            table_name,
            _phantom_d: PhantomData,
            _phantom_s: PhantomData,
            _phantom_db: PhantomData,
        }
    }

    /// Subscribe to a specific subscription key with model hash
    pub fn subscribe(
        &mut self,
        subscription_key: D::Keys,
        model_hash: [u8; 32],
    ) -> Result<(), NetabaseError>
    {
        let key_bytes = bincode::encode_to_vec(&subscription_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;
        let hash_bytes = bincode::encode_to_vec(&model_hash, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        let table = data
            .entry(self.table_name.clone())
            .or_insert_with(HashMap::new);
        table.insert(key_bytes, hash_bytes);

        Ok(())
    }

    /// Unsubscribe from a specific subscription key
    pub fn unsubscribe(
        &mut self,
        subscription_key: &D::Keys,
    ) -> Result<Option<[u8; 32]>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(subscription_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        if let Some(table) = data.get_mut(&self.table_name) {
            if let Some(hash_bytes) = table.remove(&key_bytes) {
                let (model_hash, _) = bincode::decode_from_slice::<[u8; 32], _>(
                    &hash_bytes, bincode::config::standard()
                ).map_err(crate::error::EncodingDecodingError::from)?;
                return Ok(Some(model_hash));
            }
        }

        Ok(None)
    }

    /// Get subscription data for a specific key
    pub fn get_subscription(
        &self,
        subscription_key: &D::Keys,
    ) -> Result<Option<[u8; 32]>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(subscription_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(table) = data.get(&self.table_name) {
            if let Some(hash_bytes) = table.get(&key_bytes) {
                let (model_hash, _) = bincode::decode_from_slice::<[u8; 32], _>(
                    hash_bytes, bincode::config::standard()
                ).map_err(crate::error::EncodingDecodingError::from)?;
                return Ok(Some(model_hash));
            }
        }

        Ok(None)
    }

    /// Clear all subscriptions for this subscription type
    pub fn clear_subscriptions(&mut self) -> Result<(), NetabaseError> {
        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        if let Some(table) = data.get_mut(&self.table_name) {
            table.clear();
        }

        Ok(())
    }

    /// Get the number of active subscriptions for this subscription type
    pub fn subscription_count(&self) -> Result<usize, NetabaseError> {
        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(table) = data.get(&self.table_name) {
            Ok(table.len())
        } else {
            Ok(0)
        }
    }
}
