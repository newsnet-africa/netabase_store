use crate::error::NetabaseError;
use crate::traits::convert::ToIVec;
use crate::traits::definition::NetabaseDefinitionTrait;
use crate::traits::model::NetabaseModelTrait;
use crate::traits::tree::NetabaseTreeSync;
use crate::{MaybeSend, MaybeSync};
use std::collections::HashMap;
use std::marker::PhantomData;
use std::str::FromStr;
use std::sync::{Arc, RwLock};
use strum::{IntoDiscriminant, IntoEnumIterator};

/// Type-safe in-memory key-value store.
///
/// `MemoryStore` provides a high-performance, type-safe in-memory storage backend,
/// using model discriminants as tree names and ensuring all operations are compile-time checked.
///
/// This backend is ideal for:
/// - Testing and development
/// - Temporary data storage
/// - High-performance scenarios where persistence is not required
/// - Caching layers
///
/// # Type Parameters
///
/// * `D` - A type implementing `NetabaseDefinitionTrait`, typically generated by the
///   `#[netabase_definition_module]` macro
///
/// # Examples
///
/// ## Basic Usage
///
/// ```rust
/// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// use netabase_store::databases::memory_store::MemoryStore;
/// use netabase_store::traits::tree::NetabaseTreeSync;
/// use netabase_store::traits::model::NetabaseModelTrait;
///
/// // Define your schema
/// #[netabase_definition_module(BlogDefinition, BlogKeys)]
/// mod blog {
///     use super::*;
///     use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
///              bincode::Encode, bincode::Decode,
///              serde::Serialize, serde::Deserialize)]
///     #[netabase(BlogDefinition)]
///     pub struct User {
///         #[primary_key]
///         pub id: u64,
///         pub name: String,
///         #[secondary_key]
///         pub email: String,
///     }
/// }
///
/// use blog::*;
///
/// // Create an in-memory database
/// let store = MemoryStore::<BlogDefinition>::new();
///
/// // Open a type-safe tree for the User model
/// let user_tree = store.open_tree::<User>();
///
/// // Insert a user
/// let alice = User {
///     id: 1,
///     name: "Alice".to_string(),
///     email: "alice@example.com".to_string(),
/// };
/// user_tree.put(alice.clone()).unwrap();
///
/// // Retrieve by primary key
/// let retrieved = user_tree.get(alice.primary_key()).unwrap();
/// assert_eq!(retrieved, Some(alice));
/// ```
pub struct MemoryStore<D>
where
    D: NetabaseDefinitionTrait,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Shared data storage across all trees
    data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
    pub trees: Vec<D::Discriminant>,
}

impl<D> MemoryStore<D>
where
    D: NetabaseDefinitionTrait + ToIVec,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Create a new in-memory `MemoryStore`.
    ///
    /// Creates an empty in-memory database. All data is lost when the store is dropped.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::memory_store::MemoryStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app { use super::*;
    /// #   use netabase_store::{NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode, serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(AppDef)]
    /// #   pub struct User { #[primary_key] pub id: u64, pub name: String }
    /// # }
    /// # use app::*;
    /// // Create an in-memory database
    /// let store = MemoryStore::<AppDef>::new();
    ///
    /// // Use it like any other store
    /// let user_tree = store.open_tree::<User>();
    /// ```
    pub fn new() -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            trees: D::Discriminant::iter().collect(),
        }
    }

    /// Create a new in-memory store (subscriptions available when enabled via macro)
    pub fn with_subscriptions() -> Self {
        Self::new()
    }

    /// Open a type-safe tree for a specific model type.
    ///
    /// Returns a `MemoryStoreTree` that provides CRUD operations for a single model type.
    /// Each model type gets its own tree within the database, identified by its discriminant.
    ///
    /// # Type Parameters
    ///
    /// * `M` - The model type, must implement `NetabaseModelTrait<D>`
    ///
    /// # Returns
    ///
    /// A `MemoryStoreTree<D, M>` ready for CRUD operations on the specified model type.
    /// The returned tree is tied to the lifetime of this store, ensuring it cannot outlive the database.
    pub fn open_tree<M>(&self) -> MemoryStoreTree<'_, D, M>
    where
        M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
        D: TryFrom<M> + ToIVec,
    {
        MemoryStoreTree::new(Arc::clone(&self.data), M::DISCRIMINANT)
    }

    /// Get all model discriminants (tree names) in the database schema.
    ///
    /// Returns a vector of all discriminants defined in the definition enum.
    pub fn tree_names(&self) -> Vec<D::Discriminant> {
        D::Discriminant::iter().collect()
    }

    /// Clear all data from the store.
    pub fn clear(&self) -> Result<(), NetabaseError> {
        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;
        data.clear();

        Ok(())
    }
}

impl<D> Default for MemoryStore<D>
where
    D: NetabaseDefinitionTrait + ToIVec,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn default() -> Self {
        Self::new()
    }
}

/// Type-safe tree for a specific model within a memory store.
///
/// This struct provides CRUD operations for a single model type within the in-memory database.
/// It ensures type safety by using the model's discriminant as the tree identifier.
pub struct MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
    tree_name: String,
    secondary_tree_name: String,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
    _phantom_db: PhantomData<&'db ()>,
}

impl<'db, D, M> MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Create a new MemoryStoreTree
    fn new(
        data: Arc<RwLock<HashMap<String, HashMap<Vec<u8>, Vec<u8>>>>>,
        tree_name: D::Discriminant,
    ) -> Self {
        let tree_name_str = tree_name.to_string();
        let secondary_tree_name = format!("{}_secondary", M::discriminant_name());

        Self {
            data,
            tree_name: tree_name_str,
            secondary_tree_name,
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
            _phantom_db: PhantomData,
        }
    }

    /// Insert or update a model in the tree.
    pub fn put(&self, model: M) -> Result<(), NetabaseError>
    where
        D: From<M>,
    {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let definition: D = model.into();
        #[cfg(feature = "native")]
        let value_bytes = definition.to_ivec()?;
        #[cfg(all(feature = "wasm", not(feature = "native")))]
        let value_bytes = definition.to_vec()?;
        #[cfg(not(any(feature = "native", feature = "wasm")))]
        let value_bytes = bincode::encode_to_vec(&definition, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Insert into primary tree
        {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let tree = data
                .entry(self.tree_name.clone())
                .or_insert_with(HashMap::new);
            tree.insert(key_bytes.clone(), value_bytes.to_vec());
        }

        // Insert secondary key indexes
        if !secondary_keys.is_empty() {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let sec_tree = data
                .entry(self.secondary_tree_name.clone())
                .or_insert_with(HashMap::new);

            for sec_key in secondary_keys.values() {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_tree.insert(composite_key, vec![]);
            }
        }

        Ok(())
    }

    /// Get a model by its primary key.
    pub fn get(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(tree) = data.get(&self.tree_name) {
            if let Some(value_bytes) = tree.get(&key_bytes) {
                let definition: D = {
                    let (def, _) = bincode::decode_from_slice(
                        value_bytes.as_slice(),
                        bincode::config::standard(),
                    )
                    .map_err(crate::error::EncodingDecodingError::from)?;
                    def
                };
                match M::try_from(definition) {
                    Ok(model) => return Ok(Some(model)),
                    Err(_) => {
                        return Err(NetabaseError::Storage(
                            "Failed to convert definition to model".to_string(),
                        ));
                    }
                }
            }
        }
        Ok(None)
    }

    /// Delete a model by its primary key.
    pub fn remove(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // First get the model to return it and clean up secondary keys
        let model = self.get(key.clone())?;

        if let Some(ref m) = model {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            // Remove from primary tree
            if let Some(tree) = data.get_mut(&self.tree_name) {
                tree.remove(&key_bytes);
            }

            // Remove secondary keys
            let secondary_keys = m.secondary_keys();
            if !secondary_keys.is_empty() {
                if let Some(sec_tree) = data.get_mut(&self.secondary_tree_name) {
                    for sec_key in secondary_keys.values() {
                        let composite_key = self.build_composite_key(sec_key, &key)?;
                        sec_tree.remove(&composite_key);
                    }
                }
            }
        }

        Ok(model)
    }

    /// Helper method to build composite keys for secondary indexes
    fn build_composite_key<S, P>(
        &self,
        secondary_key: &S,
        primary_key: &P,
    ) -> Result<Vec<u8>, NetabaseError>
    where
        S: bincode::Encode,
        P: bincode::Encode,
    {
        let mut composite = Vec::new();

        let sec_bytes = bincode::encode_to_vec(secondary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;
        let prim_bytes = bincode::encode_to_vec(primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        composite.extend_from_slice(&sec_bytes);
        composite.push(0xFF); // Separator
        composite.extend_from_slice(&prim_bytes);

        Ok(composite)
    }

    /// Get all models in the tree.
    pub fn get_all(&self) -> Result<Vec<M>, NetabaseError> {
        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        let mut models = Vec::new();

        if let Some(tree) = data.get(&self.tree_name) {
            for value_bytes in tree.values() {
                let definition: D = {
                    let (def, _) = bincode::decode_from_slice(
                        value_bytes.as_slice(),
                        bincode::config::standard(),
                    )
                    .map_err(crate::error::EncodingDecodingError::from)?;
                    def
                };
                let model = M::try_from(definition).map_err(|_| {
                    NetabaseError::Storage("Failed to convert definition to model".to_string())
                })?;
                models.push(model);
            }
        }

        Ok(models)
    }

    /// Get the number of models in this tree.
    pub fn len(&self) -> Result<usize, NetabaseError> {
        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        Ok(data
            .get(&self.tree_name)
            .map(|tree| tree.len())
            .unwrap_or(0))
    }

    /// Check if the tree is empty.
    pub fn is_empty(&self) -> Result<bool, NetabaseError> {
        Ok(self.len()? == 0)
    }
}

// Implement the unified NetabaseTreeSync trait for MemoryStoreTree
impl<'db, D, M> NetabaseTreeSync<'db, D, M> for MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type PrimaryKey = <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey;
    type SecondaryKeys = <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey;

    fn put(&self, model: M) -> Result<(), NetabaseError> {
        self.put(model)
    }

    fn get(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.get(key)
    }

    fn remove(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.remove(key)
    }

    fn get_by_secondary_key(
        &self,
        secondary_key: Self::SecondaryKeys,
    ) -> Result<Vec<M>, NetabaseError> {
        // For now, return an empty vector as secondary key indexing is not implemented in memory store
        // This method would need to be properly implemented with secondary key indexing
        let _ = secondary_key;
        Ok(Vec::new())
    }

    fn len(&self) -> Result<usize, NetabaseError> {
        self.len()
    }

    fn is_empty(&self) -> Result<bool, NetabaseError> {
        self.is_empty()
    }

    fn clear(&self) -> Result<(), NetabaseError> {
        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        // Clear primary tree
        if let Some(tree) = data.get_mut(&self.tree_name) {
            tree.clear();
        }

        // Clear secondary tree
        if let Some(sec_tree) = data.get_mut(&self.secondary_tree_name) {
            sec_tree.clear();
        }

        Ok(())
    }
}

impl<'db, D, M> crate::traits::store_ops::StoreOps<D, M> for MemoryStoreTree<'db, D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey:
        bincode::Decode<()> + Clone,
    <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::SecondaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + MaybeSend
        + MaybeSync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSync,
    <D as strum::IntoDiscriminant>::Discriminant: MaybeSend,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn put_raw(&self, model: M) -> Result<(), NetabaseError> {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let value_bytes = bincode::encode_to_vec(&model, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Insert into primary tree
        {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let tree = data
                .entry(self.tree_name.clone())
                .or_insert_with(HashMap::new);
            tree.insert(key_bytes.clone(), value_bytes);
        }

        // Insert secondary key indexes
        if !secondary_keys.is_empty() {
            let mut data = self
                .data
                .write()
                .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

            let sec_tree = data
                .entry(self.secondary_tree_name.clone())
                .or_insert_with(HashMap::new);

            for sec_key in secondary_keys.values() {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_tree.insert(composite_key, vec![]);
            }
        }

        Ok(())
    }

    fn get_raw(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let data = self
            .data
            .read()
            .map_err(|_| NetabaseError::Storage("Failed to acquire read lock".to_string()))?;

        if let Some(tree) = data.get(&self.tree_name) {
            if let Some(value_bytes) = tree.get(&key_bytes) {
                let definition: D = {
                    let (def, _) = bincode::decode_from_slice(
                        value_bytes.as_slice(),
                        bincode::config::standard(),
                    )
                    .map_err(crate::error::EncodingDecodingError::from)?;
                    def
                };

                let model = M::try_from(definition).map_err(|_| {
                    NetabaseError::Storage("Failed to convert definition to model".to_string())
                })?;
                Ok(Some(model))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }

    fn remove_raw(
        &self,
        key: <M::Keys as crate::traits::model::NetabaseModelTraitKey<D>>::PrimaryKey,
    ) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let mut data = self
            .data
            .write()
            .map_err(|_| NetabaseError::Storage("Failed to acquire write lock".to_string()))?;

        if let Some(tree) = data.get_mut(&self.tree_name) {
            if let Some(value_bytes) = tree.remove(&key_bytes) {
                let definition: D = {
                    let (def, _) = bincode::decode_from_slice(
                        value_bytes.as_slice(),
                        bincode::config::standard(),
                    )
                    .map_err(crate::error::EncodingDecodingError::from)?;
                    def
                };

                let model = M::try_from(definition).map_err(|_| {
                    NetabaseError::Storage("Failed to convert definition to model".to_string())
                })?;
                Ok(Some(model))
            } else {
                Ok(None)
            }
        } else {
            Ok(None)
        }
    }

    fn discriminant(&self) -> &str {
        &self.tree_name
    }
}
