use crate::definition::DynDefinition;
use crate::error::NetabaseError;
use crate::model::DynModel;
use crate::traits::convert::ToIVec;
use crate::traits::definition::NetabaseDefinitionTrait;
use crate::traits::model::NetabaseModelTrait;
use crate::traits::tree::NetabaseTreeSync;
use std::path::Path;
use std::{marker::PhantomData, str::FromStr};
use strum::{IntoDiscriminant, IntoEnumIterator};

/// Type-safe wrapper around a [sled](https://docs.rs/sled) embedded database.
///
/// `SledStore` provides a high-performance, type-safe interface to the underlying sled database,
/// using model discriminants as tree names and ensuring all operations are compile-time checked.
///
/// Sled is a modern embedded database that offers:
/// - High performance with lock-free operations
/// - Crash-safe persistence
/// - Zero-copy reads
/// - Atomic operations
///
/// # Type Parameters
///
/// * `D` - A type implementing `NetabaseDefinitionTrait`, typically generated by the
///   `#[netabase_definition_module]` macro
///
/// # Examples
///
/// ## Basic Usage
///
/// ```rust
/// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// use netabase_store::databases::sled_store::SledStore;
/// use netabase_store::traits::tree::NetabaseTreeSync;
/// use netabase_store::traits::model::NetabaseModelTrait;
///
/// // Define your schema
/// #[netabase_definition_module(BlogDefinition, BlogKeys)]
/// mod blog {
///     use super::*;
///     use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
///              bincode::Encode, bincode::Decode,
///              serde::Serialize, serde::Deserialize)]
///     #[netabase(BlogDefinition)]
///     pub struct User {
///         #[primary_key]
///         pub id: u64,
///         pub name: String,
///         #[secondary_key]
///         pub email: String,
///     }
/// }
///
/// use blog::*;
///
/// // Create a temporary database for testing
/// let store = SledStore::<BlogDefinition>::temp().unwrap();
///
/// // Open a type-safe tree for the User model
/// let user_tree = store.open_tree::<User>();
///
/// // Insert a user
/// let alice = User {
///     id: 1,
///     name: "Alice".to_string(),
///     email: "alice@example.com".to_string(),
/// };
/// user_tree.put(alice.clone()).unwrap();
///
/// // Retrieve by primary key
/// let retrieved = user_tree.get(alice.primary_key()).unwrap();
/// assert_eq!(retrieved, Some(alice));
/// ```
///
/// ## Persistent Storage
///
/// ```rust
/// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// # use netabase_store::databases::sled_store::SledStore;
/// #
/// # #[netabase_definition_module(MyDefinition, MyKeys)]
/// # mod my_models {
/// #     use super::*;
/// #     use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// #     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
/// #              serde::Serialize, serde::Deserialize)]
/// #     #[netabase(MyDefinition)]
/// #     pub struct MyModel { #[primary_key] pub id: u64 }
/// # }
/// # use my_models::*;
/// // Open a persistent database at a specific path
/// let store = SledStore::<MyDefinition>::new("./my_app_data").unwrap();
///
/// // Data persists across application restarts
/// // store.flush().unwrap(); // Force flush to disk if needed
/// ```
///
/// # Performance Tips
///
/// - Use `flush()` sparingly - sled automatically persists data
/// - Batch multiple operations when possible
/// - Use `temp()` for testing to avoid disk I/O
/// - Secondary key queries are O(m) where m is the number of matches
/// - Primary key access is O(log n) where n is total records
///
/// # See Also
///
/// - [`SledStoreTree`] - Type-safe tree interface for a specific model
/// - [`NetabaseTreeSync`] - Unified trait interface for CRUD operations
/// - [`RedbStore`](crate::databases::redb_store::RedbStore) - Alternative backend with ACID guarantees
pub struct SledStore<D>
where
    D: NetabaseDefinitionTrait,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    db: sled::Db,
    pub trees: Vec<D::Discriminant>,
}

impl<D> SledStore<D>
where
    D: NetabaseDefinitionTrait,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Get direct access to the underlying sled database.
    ///
    /// This provides low-level access to the sled database for advanced operations
    /// that are not covered by the type-safe interface.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(MyDef, MyKeys)]
    /// # mod my { use super::*;
    /// #   use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode, serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(MyDef)]
    /// #   pub struct MyModel { #[primary_key] pub id: u64 }
    /// # }
    /// # use my::*;
    /// let store = SledStore::<MyDef>::temp().unwrap();
    ///
    /// // Access the underlying sled database
    /// let sled_db = store.db();
    ///
    /// // Perform low-level operations
    /// let size_on_disk = sled_db.size_on_disk().unwrap();
    /// println!("Database size: {} bytes", size_on_disk);
    /// ```
    pub fn db(&self) -> &sled::Db {
        &self.db
    }
}

impl<D> SledStore<D>
where
    D: NetabaseDefinitionTrait + ToIVec,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Open a new `SledStore` at the given filesystem path.
    ///
    /// Creates or opens a persistent sled database at the specified path. The database
    /// will automatically create the directory if it doesn't exist.
    ///
    /// # Arguments
    ///
    /// * `path` - The filesystem path where the database should be stored
    ///
    /// # Returns
    ///
    /// * `Ok(SledStore<D>)` - Successfully opened database
    /// * `Err(NetabaseError)` - Failed to open database (I/O error, permissions, etc.)
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app { use super::*;
    /// #   use netabase_store::{NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode, serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(AppDef)]
    /// #   pub struct User { #[primary_key] pub id: u64, pub name: String }
    /// # }
    /// # use app::*;
    /// // Open a persistent database
    /// let store = SledStore::<AppDef>::new("./app_database").unwrap();
    ///
    /// // Data persists across application restarts
    /// let user_tree = store.open_tree::<User>();
    /// ```
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(TestDef, TestKeys)]
    /// # mod test { use super::*;
    /// #   use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode, serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(TestDef)]
    /// #   pub struct Item { #[primary_key] pub id: u64 }
    /// # }
    /// # use test::*;
    /// // Use a temporary directory for testing
    /// let temp_dir = tempfile::tempdir().unwrap();
    /// let db_path = temp_dir.path().join("test_db");
    /// let store = SledStore::<TestDef>::new(&db_path).unwrap();
    /// ```
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self, NetabaseError> {
        let db = sled::open(path)?;
        Ok(Self {
            db,
            trees: D::Discriminant::iter().collect(),
        })
    }

    /// Create a temporary in-memory `SledStore` for testing.
    ///
    /// Creates a temporary database that exists only in memory and is automatically
    /// cleaned up when dropped. This is ideal for unit tests and examples where
    /// persistence is not needed.
    ///
    /// # Returns
    ///
    /// * `Ok(SledStore<D>)` - Successfully created temporary database
    /// * `Err(NetabaseError)` - Failed to create database (rare, usually indicates system issues)
    ///
    /// # Examples
    ///
    /// ```rust
    /// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// use netabase_store::databases::sled_store::SledStore;
    /// use netabase_store::traits::tree::NetabaseTreeSync;
    /// use netabase_store::traits::model::NetabaseModelTrait;
    ///
    /// #[netabase_definition_module(TestDef, TestKeys)]
    /// mod test {
    ///     use super::*;
    ///     use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    ///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
    ///              bincode::Encode, bincode::Decode,
    ///              serde::Serialize, serde::Deserialize)]
    ///     #[netabase(TestDef)]
    ///     pub struct Product {
    ///         #[primary_key]
    ///         pub id: String,
    ///         pub name: String,
    ///         pub price: f64,
    ///     }
    /// }
    /// use test::*;
    ///
    /// // Create temporary database
    /// let store = SledStore::<TestDef>::temp().unwrap();
    /// let product_tree = store.open_tree::<Product>();
    ///
    /// // Use normally
    /// let product = Product {
    ///     id: "prod-1".to_string(),
    ///     name: "Widget".to_string(),
    ///     price: 29.99,
    /// };
    /// product_tree.put(product.clone()).unwrap();
    ///
    /// // Verify
    /// let retrieved = product_tree.get(product.primary_key()).unwrap();
    /// assert_eq!(retrieved, Some(product));
    /// // Database is automatically cleaned up when `store` is dropped
    /// ```
    pub fn temp() -> Result<Self, NetabaseError> {
        let config = sled::Config::new().temporary(true);
        let db = config.open()?;
        Ok(Self {
            db,
            trees: D::Discriminant::iter().collect(),
        })
    }

    /// Open a type-safe tree for a specific model type.
    ///
    /// Returns a `SledStoreTree` that provides CRUD operations for a single model type.
    /// Each model type gets its own tree within the database, identified by its discriminant.
    ///
    /// The returned tree is type-safe and will only accept/return instances of the specified model.
    ///
    /// # Type Parameters
    ///
    /// * `M` - The model type, must implement `NetabaseModelTrait<D>`
    ///
    /// # Returns
    ///
    /// A `SledStoreTree<D, M>` ready for CRUD operations on the specified model type.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// use netabase_store::databases::sled_store::SledStore;
    /// use netabase_store::traits::tree::NetabaseTreeSync;
    ///
    /// #[netabase_definition_module(ShopDef, ShopKeys)]
    /// mod shop {
    ///     use super::*;
    ///
    /// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    ///
    ///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
    ///              bincode::Encode, bincode::Decode,
    ///              serde::Serialize, serde::Deserialize)]
    ///     #[netabase(ShopDef)]
    ///     pub struct Customer {
    ///         #[primary_key]
    ///         pub id: u64,
    ///         pub name: String,
    ///         #[secondary_key]
    ///         pub email: String,
    ///     }
    ///
    ///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
    ///              bincode::Encode, bincode::Decode,
    ///              serde::Serialize, serde::Deserialize)]
    ///     #[netabase(ShopDef)]
    ///     pub struct Order {
    ///         #[primary_key]
    ///         pub id: u64,
    ///         pub customer_id: u64,
    ///         pub total: f64,
    ///     }
    /// }
    /// use shop::*;
    ///
    /// let store = SledStore::<ShopDef>::temp().unwrap();
    ///
    /// // Open separate trees for each model
    /// let customer_tree = store.open_tree::<Customer>();
    /// let order_tree = store.open_tree::<Order>();
    ///
    /// // Each tree is independent and type-safe
    /// let customer = Customer {
    ///     id: 1,
    ///     name: "Alice".to_string(),
    ///     email: "alice@example.com".to_string(),
    /// };
    /// customer_tree.put(customer).unwrap();
    ///
    /// let order = Order {
    ///     id: 100,
    ///     customer_id: 1,
    ///     total: 99.99,
    /// };
    /// order_tree.put(order).unwrap();
    ///
    /// // Verify independent storage
    /// assert_eq!(customer_tree.len(), 1);
    /// assert_eq!(order_tree.len(), 1);
    /// ```
    pub fn open_tree<M>(&self) -> SledStoreTree<D, M>
    where
        M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
        D: TryFrom<M> + ToIVec,
    {
        SledStoreTree::new(&self.db, M::DISCRIMINANT)
    }

    pub fn open_t(&self, _key: D::Keys) {
        // TODO: Implement this method properly
        // let _inner = key.inner();
        // let _ = self.open_tree::<M>();
    }

    /// Get all model discriminants (tree names) in the database schema.
    ///
    /// Returns a vector of all discriminants defined in the definition enum.
    /// Each discriminant corresponds to a model type and its associated tree.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// #[netabase_definition_module(MultiModelDef, MultiModelKeys)]
    /// mod models {
    ///     use super::*;
    /// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    ///     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    ///              serde::Serialize, serde::Deserialize)]
    ///     #[netabase(MultiModelDef)]
    ///     pub struct User { #[primary_key] pub id: u64 }
    ///
    ///     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    ///              serde::Serialize, serde::Deserialize)]
    ///     #[netabase(MultiModelDef)]
    ///     pub struct Post { #[primary_key] pub id: u64 }
    /// }
    /// use models::*;
    ///
    /// let store = SledStore::<MultiModelDef>::temp().unwrap();
    /// let tree_names = store.tree_names();
    ///
    /// // Will contain discriminants for both User and Post
    /// assert_eq!(tree_names.len(), 2);
    /// ```
    pub fn tree_names(&self) -> Vec<D::Discriminant> {
        D::Discriminant::iter().collect()
    }

    /// Flush all pending writes to disk.
    ///
    /// Forces sled to flush all buffered writes to persistent storage.
    /// This ensures data durability but may impact performance if called too frequently.
    ///
    /// Sled automatically flushes data periodically, so manual flushes are typically
    /// only needed when:
    /// - You need to guarantee data is on disk before continuing
    /// - Before shutting down the application
    /// - After critical writes that must not be lost
    ///
    /// # Returns
    ///
    /// * `Ok(usize)` - Number of bytes written to disk
    /// * `Err(NetabaseError)` - I/O error during flush
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app { use super::*;
    /// #   use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #   #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    /// #            serde::Serialize, serde::Deserialize)]
    /// #   #[netabase(AppDef)]
    /// #   pub struct Config { #[primary_key] pub key: String, pub value: String }
    /// # }
    /// # use app::*;
    /// # let temp_dir = tempfile::tempdir().unwrap();
    /// # let db_path = temp_dir.path().join("db");
    /// let store = SledStore::<AppDef>::new(&db_path).unwrap();
    /// let config_tree = store.open_tree::<Config>();
    ///
    /// // Write critical configuration
    /// let config = Config {
    ///     key: "api_key".to_string(),
    ///     value: "secret123".to_string(),
    /// };
    /// config_tree.put(config).unwrap();
    ///
    /// // Ensure it's written to disk before continuing
    /// let bytes_flushed = store.flush().unwrap();
    /// println!("Flushed {} bytes to disk", bytes_flushed);
    /// ```
    pub fn flush(&self) -> Result<usize, NetabaseError> {
        Ok(self.db.flush()?)
    }
}

/// Type-safe wrapper around a sled tree for a specific model type.
///
/// `SledStoreTree` provides CRUD operations for a single model type with:
/// - Automatic bincode serialization/deserialization
/// - Primary key indexing
/// - Secondary key indexing and querying
/// - Type-safe operations (compile-time checking)
///
/// This is the primary interface for interacting with stored models. Each model type
/// gets its own tree, providing isolation and type safety.
///
/// # Type Parameters
///
/// * `D` - The definition type (generated by `#[netabase_definition_module]`)
/// * `M` - The model type (annotated with `#[derive(NetabaseModel)]`)
///
/// # Examples
///
/// ## Basic CRUD Operations
///
/// ```rust
/// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
/// use netabase_store::databases::sled_store::SledStore;
/// use netabase_store::traits::tree::NetabaseTreeSync;
/// use netabase_store::traits::model::NetabaseModelTrait;
///
/// #[netabase_definition_module(StoreDef, StoreKeys)]
/// mod store {
///     use super::*;
/// use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
///     #[derive(NetabaseModel, Clone, Debug, PartialEq,
///              bincode::Encode, bincode::Decode,
///              serde::Serialize, serde::Deserialize)]
///     #[netabase(StoreDef)]
///     pub struct Book {
///         #[primary_key]
///         pub isbn: String,
///         pub title: String,
///         pub author: String,
///         #[secondary_key]
///         pub genre: String,
///     }
/// }
/// use store::*;
///
/// let store = SledStore::<StoreDef>::temp().unwrap();
/// let books = store.open_tree::<Book>();
///
/// // Create
/// let book = Book {
///     isbn: "978-0-12-345678-9".to_string(),
///     title: "Rust Programming".to_string(),
///     author: "Alice".to_string(),
///     genre: "Tech".to_string(),
/// };
/// books.put(book.clone()).unwrap();
///
/// // Read by primary key
/// let retrieved = books.get(book.primary_key()).unwrap();
/// assert_eq!(retrieved, Some(book.clone()));
///
/// // Query by secondary key
/// let tech_books = books.get_by_secondary_key(book.secondary_keys()[0].clone()).unwrap();
/// assert_eq!(tech_books.len(), 1);
///
/// // Update (same as put)
/// let mut updated_book = book.clone();
/// updated_book.author = "Alice Smith".to_string();
/// books.put(updated_book.clone()).unwrap();
///
/// // Delete
/// let deleted = books.remove(updated_book.primary_key()).unwrap();
/// assert!(deleted.is_some());
/// ```
///
/// # See Also
///
/// - [`NetabaseTreeSync`] - The unified trait interface this implements
/// - [`SledStore`] - The parent store that creates trees
pub struct SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    tree: sled::Tree,
    secondary_tree: sled::Tree,
    pub db: sled::Db,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
}

impl<D, M> SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    /// Create a new SledStoreTree
    fn new(db: &sled::Db, tree_name: D::Discriminant) -> Self {
        let tree = db
            .open_tree(tree_name.to_string())
            .expect("Failed to open tree");
        let sec_tree_name = format!("{}_secondary", M::discriminant_name());
        let secondary_tree = db
            .open_tree(sec_tree_name)
            .expect("Failed to open secondary tree");
        Self {
            tree,
            secondary_tree,
            db: db.clone(),
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
        }
    }

    /// Insert or update a model in the tree.
    ///
    /// If a model with the same primary key already exists, it will be overwritten.
    /// This method automatically:
    /// - Serializes the model using bincode
    /// - Updates secondary key indexes atomically using batching
    /// - Persists the data to disk (eventually, via sled's write-ahead log)
    ///
    /// # Arguments
    ///
    /// * `model` - The model instance to insert or update (consumed)
    ///
    /// # Returns
    ///
    /// * `Ok(())` - Model successfully stored
    /// * `Err(NetabaseError)` - Serialization or I/O error
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # use netabase_store::traits::model::NetabaseModelTrait;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, PartialEq, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Task { #[primary_key] pub id: u64, pub title: String, pub done: bool }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let tasks = store.open_tree::<Task>();
    ///
    /// // Insert a new task
    /// let task = Task { id: 1, title: "Learn Rust".to_string(), done: false };
    /// tasks.put(task).unwrap();
    ///
    /// // Update the task (same primary key)
    /// let updated_task = Task { id: 1, title: "Learn Rust".to_string(), done: true };
    /// tasks.put(updated_task).unwrap();
    ///
    /// // Verify update
    /// let retrieved_task = Task { id: 1, title: "".to_string(), done: false };
    /// let retrieved = tasks.get(retrieved_task.primary_key()).unwrap().unwrap();
    /// assert_eq!(retrieved.done, true);
    /// ```
    pub fn put(&self, model: M) -> Result<(), NetabaseError>
    where
        D: From<M>,
    {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let definition: D = model.into();
        let value_bytes = definition.to_ivec()?;

        // Use batch for atomic operations
        let mut batch = sled::Batch::default();
        batch.insert(key_bytes, value_bytes.as_ref());
        self.tree.apply_batch(batch)?;

        // Batch secondary key inserts
        if !secondary_keys.is_empty() {
            let mut sec_batch = sled::Batch::default();
            for sec_key in secondary_keys {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_batch.insert(composite_key, &[] as &[u8]);
            }
            self.secondary_tree.apply_batch(sec_batch)?;
        }

        Ok(())
    }

    /// Get a model by its primary key.
    ///
    /// Retrieves a model from the tree using its primary key. Returns `None` if no
    /// model with the given key exists.
    ///
    /// # Arguments
    ///
    /// * `key` - The primary key of the model to retrieve
    ///
    /// # Returns
    ///
    /// * `Ok(Some(model))` - Model found and deserialized successfully
    /// * `Ok(None)` - No model with this key exists
    /// * `Err(NetabaseError)` - Deserialization or I/O error
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # use netabase_store::traits::model::NetabaseModelTrait;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, PartialEq, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct User { #[primary_key] pub id: u64, pub name: String }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let users = store.open_tree::<User>();
    ///
    /// let user = User { id: 42, name: "Bob".to_string() };
    /// users.put(user.clone()).unwrap();
    ///
    /// // Get existing user
    /// let found = users.get(user.primary_key()).unwrap();
    /// assert_eq!(found, Some(user));
    ///
    /// // Get non-existent user
    /// let not_found = users.get(User { id: 999, name: "Nobody".to_string() }.primary_key()).unwrap();
    /// assert_eq!(not_found, None);
    /// ```
    pub fn get(&self, key: M::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        match self.tree.get(key_bytes)? {
            Some(ivec) => {
                let definition = D::from_ivec(&ivec)?;
                match M::try_from(definition) {
                    Ok(model) => Ok(Some(model)),
                    Err(_) => Ok(None),
                }
            }
            None => Ok(None),
        }
    }

    /// Delete a model by its primary key.
    ///
    /// Removes the model and all its secondary key indexes. Returns the deleted model
    /// if it existed, or `None` if no model with the given key was found.
    ///
    /// # Arguments
    ///
    /// * `key` - The primary key of the model to delete
    ///
    /// # Returns
    ///
    /// * `Ok(Some(model))` - Model was deleted (returns the deleted model)
    /// * `Ok(None)` - No model with this key existed
    /// * `Err(NetabaseError)` - Deserialization or I/O error
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # use netabase_store::traits::model::NetabaseModelTrait;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, PartialEq, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Article { #[primary_key] pub id: u64, pub title: String }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let articles = store.open_tree::<Article>();
    ///
    /// let article = Article { id: 1, title: "Hello".to_string() };
    /// articles.put(article.clone()).unwrap();  // Clone needed since we use article later
    ///
    /// // Delete and get the deleted model
    /// let deleted = articles.remove(article.primary_key()).unwrap();
    /// assert_eq!(deleted, Some(article.clone()));
    ///
    /// // Verify it's gone
    /// let gone = articles.get(article.primary_key()).unwrap();
    /// assert_eq!(gone, None);
    /// ```
    pub fn remove(&self, key: M::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        match self.tree.remove(key_bytes)? {
            Some(ivec) => {
                let definition = D::from_ivec(&ivec)?;
                match M::try_from(definition) {
                    Ok(model) => {
                        // Clean up secondary keys using batch
                        let secondary_keys = model.secondary_keys();
                        if !secondary_keys.is_empty() {
                            let mut sec_batch = sled::Batch::default();
                            for sec_key in &secondary_keys {
                                let composite_key = self.build_composite_key(sec_key, &key)?;
                                sec_batch.remove(composite_key);
                            }
                            self.secondary_tree.apply_batch(sec_batch)?;
                        }
                        Ok(Some(model))
                    }
                    Err(_) => Ok(None),
                }
            }
            None => Ok(None),
        }
    }

    /// Iterate over all models in the tree.
    ///
    /// Returns an iterator that yields `(primary_key, model)` pairs for all models in the tree.
    /// The iteration order is determined by the underlying sled tree (lexicographically by key bytes).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Item { #[primary_key] pub id: u64, pub value: String }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let items = store.open_tree::<Item>();
    ///
    /// items.put(Item { id: 1, value: "first".into() }).unwrap();
    /// items.put(Item { id: 2, value: "second".into() }).unwrap();
    ///
    /// // Iterate over all items
    /// for result in items.iter() {
    ///     let (key, item) = result.unwrap();
    ///     println!("Item {}: {}", key.0, item.value);
    /// }
    /// ```
    pub fn iter(&self) -> SledIter<D, M> {
        SledIter {
            inner: self.tree.iter(),
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
        }
    }

    /// Get the total number of models in the tree.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Counter { #[primary_key] pub id: u64 }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let counters = store.open_tree::<Counter>();
    ///
    /// assert_eq!(counters.len(), 0);
    /// counters.put(Counter { id: 1 }).unwrap();
    /// assert_eq!(counters.len(), 1);
    /// ```
    pub fn len(&self) -> usize {
        self.tree.len()
    }

    /// Check if the tree contains no models.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Record { #[primary_key] pub id: u64 }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let records = store.open_tree::<Record>();
    ///
    /// assert!(records.is_empty());
    /// records.put(Record { id: 1 }).unwrap();
    /// assert!(!records.is_empty());
    /// ```
    pub fn is_empty(&self) -> bool {
        self.tree.is_empty()
    }

    /// Clear all models from the tree.
    ///
    /// Removes all models and their secondary key indexes from the tree.
    /// This is more efficient than removing models one-by-one.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Temp { #[primary_key] pub id: u64 }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let temps = store.open_tree::<Temp>();
    ///
    /// temps.put(Temp { id: 1 }).unwrap();
    /// temps.put(Temp { id: 2 }).unwrap();
    /// assert_eq!(temps.len(), 2);
    ///
    /// temps.clear().unwrap();
    /// assert_eq!(temps.len(), 0);
    /// ```
    pub fn clear(&self) -> Result<(), NetabaseError> {
        self.tree.clear()?;
        Ok(())
    }

    /// Build a composite key from secondary key + primary key
    fn build_composite_key(
        &self,
        secondary_key: &M::SecondaryKeys,
        primary_key: &M::PrimaryKey,
    ) -> Result<Vec<u8>, NetabaseError> {
        let mut composite_key = bincode::encode_to_vec(secondary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;
        let prim_key_bytes = bincode::encode_to_vec(primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Append primary key to secondary key to create composite key
        composite_key.extend_from_slice(&prim_key_bytes);
        Ok(composite_key)
    }

    /// Find all models matching a secondary key value.
    ///
    /// Queries the secondary key index to find all models with the given secondary key value.
    /// Multiple models can have the same secondary key value, so this returns a vector.
    ///
    /// # Performance
    ///
    /// Secondary key queries are O(m) where m is the number of matching records.
    /// Each match requires a primary key lookup to retrieve the full model.
    ///
    /// # Arguments
    ///
    /// * `secondary_key` - The secondary key variant and value to search for
    ///
    /// # Returns
    ///
    /// * `Ok(Vec<M>)` - All models matching the secondary key (may be empty)
    /// * `Err(NetabaseError)` - I/O or deserialization error
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// # use netabase_store::databases::sled_store::SledStore;
    /// # use netabase_store::traits::model::NetabaseModelTrait;
    /// # #[netabase_definition_module(AppDef, AppKeys)]
    /// # mod app {
    /// #     use super::*;
    /// # use netabase_store::{netabase_definition_module, NetabaseModel, netabase};
    /// #     #[derive(NetabaseModel, Clone, Debug, PartialEq, bincode::Encode, bincode::Decode,
    /// #              serde::Serialize, serde::Deserialize)]
    /// #     #[netabase(AppDef)]
    /// #     pub struct Person {
    /// #         #[primary_key] pub id: u64,
    /// #         pub name: String,
    /// #         #[secondary_key] pub city: String,
    /// #         #[secondary_key] pub age: u32,
    /// #     }
    /// # }
    /// # use app::*;
    /// let store = SledStore::<AppDef>::temp().unwrap();
    /// let people = store.open_tree::<Person>();
    ///
    /// // Add multiple people in the same city
    /// people.put(Person { id: 1, name: "Alice".into(), city: "NYC".into(), age: 30 }).unwrap();
    /// people.put(Person { id: 2, name: "Bob".into(), city: "NYC".into(), age: 25 }).unwrap();
    /// people.put(Person { id: 3, name: "Carol".into(), city: "LA".into(), age: 30 }).unwrap();
    ///
    /// // Query by city (secondary key - use the first person's city value)
    /// let alice = Person { id: 1, name: "Alice".into(), city: "NYC".into(), age: 30 };
    /// let nyc_people = people.get_by_secondary_key(
    ///     alice.secondary_keys()[0].clone()
    /// ).unwrap();
    /// assert_eq!(nyc_people.len(), 2);
    ///
    /// // Query by age (another secondary key - use the city secondary key)
    /// let age_30 = people.get_by_secondary_key(
    ///     alice.secondary_keys()[1].clone()
    /// ).unwrap();
    /// assert_eq!(age_30.len(), 2);
    /// ```
    pub fn get_by_secondary_key(
        &self,
        secondary_key: M::SecondaryKeys,
    ) -> Result<Vec<M>, NetabaseError>
    where
        M::PrimaryKey: bincode::Decode<()>,
    {
        let sec_key_bytes = bincode::encode_to_vec(&secondary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        let mut results = Vec::new();
        for item in self.secondary_tree.scan_prefix(&sec_key_bytes) {
            let (composite_key, _) = item?;
            // Extract primary key from composite key (skip secondary key bytes)
            let prim_key_start = sec_key_bytes.len();
            if composite_key.len() > prim_key_start {
                let (primary_key, _) = bincode::decode_from_slice::<M::PrimaryKey, _>(
                    &composite_key[prim_key_start..],
                    bincode::config::standard(),
                )
                .map_err(crate::error::EncodingDecodingError::from)?;

                if let Some(model) = self.get(primary_key)? {
                    results.push(model);
                }
            }
        }

        Ok(results)
    }
}

/// Iterator over models in a SledStoreTree
pub struct SledIter<D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    inner: sled::Iter,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
}

impl<D, M> Iterator for SledIter<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec,
    M: NetabaseModelTrait<D> + TryFrom<D>,
    M::PrimaryKey: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type Item = Result<(M::PrimaryKey, M), NetabaseError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.inner.next().map(|result| {
            result.map_err(|e| e.into()).and_then(|(k, v)| {
                let (key, _) =
                    bincode::decode_from_slice::<M::PrimaryKey, _>(&k, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;
                let definition = D::from_ivec(&v)?;
                let model = M::try_from(definition).map_err(|_| {
                    crate::error::NetabaseError::Conversion(
                        crate::error::EncodingDecodingError::Decoding(
                            bincode::error::DecodeError::Other("Type conversion failed"),
                        ),
                    )
                })?;
                Ok((key, model))
            })
        })
    }
}

// Implement the unified NetabaseTreeSync trait for SledStoreTree
impl<D, M> NetabaseTreeSync<D, M> for SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone,
    M::PrimaryKey: bincode::Decode<()> + Clone,
    M::SecondaryKeys: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type PrimaryKey = M::PrimaryKey;
    type SecondaryKeys = M::SecondaryKeys;

    fn put(&self, model: M) -> Result<(), NetabaseError> {
        self.put(model)
    }

    fn get(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.get(key)
    }

    fn remove(&self, key: Self::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        self.remove(key)
    }

    fn get_by_secondary_key(
        &self,
        secondary_key: Self::SecondaryKeys,
    ) -> Result<Vec<M>, NetabaseError> {
        self.get_by_secondary_key(secondary_key)
    }

    fn is_empty(&self) -> Result<bool, NetabaseError> {
        Ok(self.is_empty())
    }

    fn len(&self) -> Result<usize, NetabaseError> {
        Ok(self.len())
    }

    fn clear(&self) -> Result<(), NetabaseError> {
        self.clear()
    }
}

// Implement StoreOps trait for SledStoreTree
impl<D, M> crate::traits::store_ops::StoreOps<D, M> for SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone + bincode::Decode<()>,
    M::PrimaryKey: bincode::Decode<()> + Clone,
    M::SecondaryKeys: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn put_raw(&self, model: M) -> Result<(), NetabaseError> {
        // Store the model directly, not wrapped in Definition
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Store raw model directly (not wrapped in Definition)
        let value_bytes = bincode::encode_to_vec(&model, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Use batch for atomic operations
        let mut batch = sled::Batch::default();
        batch.insert(key_bytes, value_bytes);
        self.tree.apply_batch(batch)?;

        // Batch secondary key inserts
        if !secondary_keys.is_empty() {
            let mut sec_batch = sled::Batch::default();
            for sec_key in secondary_keys {
                let composite_key = self.build_composite_key(&sec_key, &primary_key)?;
                sec_batch.insert(composite_key, &[] as &[u8]);
            }
            self.secondary_tree.apply_batch(sec_batch)?;
        }

        Ok(())
    }

    fn get_raw(&self, key: M::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        // Get the model directly (not wrapped in Definition)
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        match self.tree.get(key_bytes)? {
            Some(ivec) => {
                // Decode directly as model (not Definition)
                let (model, _) =
                    bincode::decode_from_slice::<M, _>(&ivec, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;
                Ok(Some(model))
            }
            None => Ok(None),
        }
    }

    fn remove_raw(&self, key: M::PrimaryKey) -> Result<Option<M>, NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        match self.tree.remove(key_bytes)? {
            Some(ivec) => {
                // Decode directly as model (not Definition)
                let (model, _) =
                    bincode::decode_from_slice::<M, _>(&ivec, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;

                // Clean up secondary keys using batch
                let secondary_keys = model.secondary_keys();
                if !secondary_keys.is_empty() {
                    let mut sec_batch = sled::Batch::default();
                    for sec_key in &secondary_keys {
                        let composite_key = self.build_composite_key(sec_key, &key)?;
                        sec_batch.remove(composite_key);
                    }
                    self.secondary_tree.apply_batch(sec_batch)?;
                }
                Ok(Some(model))
            }
            None => Ok(None),
        }
    }

    fn discriminant(&self) -> &str {
        M::discriminant_name()
    }
}

// Implement StoreOpsSecondary trait for SledStoreTree
impl<D, M> crate::traits::store_ops::StoreOpsSecondary<D, M> for SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone + bincode::Decode<()>,
    M::PrimaryKey: bincode::Decode<()> + Clone,
    M::SecondaryKeys: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn get_by_secondary_key_raw(
        &self,
        secondary_key: M::SecondaryKeys,
    ) -> Result<Vec<M>, NetabaseError> {
        // Use existing get_by_secondary_key which already returns raw models
        self.get_by_secondary_key(secondary_key)
    }
}

// Batch builder for Sled
pub struct SledBatchBuilder<D, M>
where
    D: NetabaseDefinitionTrait,
    M: NetabaseModelTrait<D>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    tree: sled::Tree,
    secondary_tree: sled::Tree,
    primary_batch: sled::Batch,
    secondary_batch: sled::Batch,
    _phantom_d: PhantomData<D>,
    _phantom_m: PhantomData<M>,
}

impl<D, M> crate::traits::batch::BatchBuilder<D, M> for SledBatchBuilder<D, M>
where
    D: NetabaseDefinitionTrait + From<M> + ToIVec,
    M: NetabaseModelTrait<D> + Clone,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    fn put(&mut self, model: M) -> Result<(), NetabaseError> {
        let primary_key = model.primary_key();
        let secondary_keys = model.secondary_keys();

        let key_bytes = bincode::encode_to_vec(&primary_key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        // Store raw model directly
        let value_bytes = bincode::encode_to_vec(&model, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        self.primary_batch.insert(key_bytes.clone(), value_bytes);

        // Add secondary key entries
        if !secondary_keys.is_empty() {
            for sec_key in secondary_keys {
                let sec_key_bytes =
                    bincode::encode_to_vec(&sec_key, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;
                let prim_key_bytes =
                    bincode::encode_to_vec(&primary_key, bincode::config::standard())
                        .map_err(crate::error::EncodingDecodingError::from)?;

                let mut composite_key = sec_key_bytes;
                composite_key.extend_from_slice(&prim_key_bytes);

                self.secondary_batch.insert(composite_key, &[] as &[u8]);
            }
        }

        Ok(())
    }

    fn remove(&mut self, key: M::PrimaryKey) -> Result<(), NetabaseError> {
        let key_bytes = bincode::encode_to_vec(&key, bincode::config::standard())
            .map_err(crate::error::EncodingDecodingError::from)?;

        self.primary_batch.remove(key_bytes);

        // Note: We can't clean up secondary keys in the batch without knowing them
        // This is a limitation of the batch API - ideally we'd fetch the model first

        Ok(())
    }

    fn commit(self) -> Result<(), NetabaseError> {
        self.tree.apply_batch(self.primary_batch)?;
        self.secondary_tree.apply_batch(self.secondary_batch)?;
        Ok(())
    }
}

// Implement Batchable trait for SledStoreTree
impl<D, M> crate::traits::batch::Batchable<D, M> for SledStoreTree<D, M>
where
    D: NetabaseDefinitionTrait + TryFrom<M> + ToIVec + From<M>,
    M: NetabaseModelTrait<D> + TryFrom<D> + Into<D> + Clone,
    M::PrimaryKey: bincode::Decode<()> + Clone,
    M::SecondaryKeys: bincode::Decode<()>,
    <D as IntoDiscriminant>::Discriminant: Clone
        + Copy
        + std::fmt::Debug
        + std::fmt::Display
        + PartialEq
        + Eq
        + std::hash::Hash
        + strum::IntoEnumIterator
        + Send
        + Sync
        + 'static
        + FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Copy,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Debug,
    <D as strum::IntoDiscriminant>::Discriminant: std::hash::Hash,
    <D as strum::IntoDiscriminant>::Discriminant: std::cmp::Eq,
    <D as strum::IntoDiscriminant>::Discriminant: std::fmt::Display,
    <D as strum::IntoDiscriminant>::Discriminant: FromStr,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Sync,
    <D as strum::IntoDiscriminant>::Discriminant: std::marker::Send,
    <D as strum::IntoDiscriminant>::Discriminant: strum::IntoEnumIterator,
    <D as strum::IntoDiscriminant>::Discriminant: std::convert::AsRef<str>,
{
    type Batch = SledBatchBuilder<D, M>;

    fn create_batch(&self) -> Result<Self::Batch, NetabaseError> {
        Ok(SledBatchBuilder {
            tree: self.tree.clone(),
            secondary_tree: self.secondary_tree.clone(),
            primary_batch: sled::Batch::default(),
            secondary_batch: sled::Batch::default(),
            _phantom_d: PhantomData,
            _phantom_m: PhantomData,
        })
    }
}

// Tests are in the tests/ directory
